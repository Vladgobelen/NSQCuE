AuthManager.js:
import InviteManager from './InviteManager.js';

class AuthManager {
    static STORAGE_KEY = 'voicechat_users';
    static LAST_USER_KEY = 'voicechat_lastuser';

    static getAllUsers() {
        try {
            return JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {};
        } catch {
            return {};
        }
    }

    static saveAllUsers(users) {
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(users));
    }

    static loadLastUser() {
        try {
            return JSON.parse(localStorage.getItem(this.LAST_USER_KEY));
        } catch {
            return null;
        }
    }

    static saveLastUser(user) {
        localStorage.setItem(this.LAST_USER_KEY, JSON.stringify(user));
    }

    static removeUser(username) {
        const users = this.getAllUsers();
        delete users[username];
        this.saveAllUsers(users);
        
        const lastUser = this.loadLastUser();
        if (lastUser && lastUser.username === username) {
            localStorage.removeItem(this.LAST_USER_KEY);
        }
    }

    static async tryAutoLogin(client) {
        const lastUser = this.loadLastUser();
        if (!lastUser) return false;

        const isValid = await this.validateToken(client, lastUser.userId, lastUser.token);
        if (!isValid) {
            this.removeUser(lastUser.username);
            return false;
        }

        client.userId = lastUser.userId;
        client.token = lastUser.token;
        client.username = lastUser.username;
        
        // –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º InviteManager –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∞–≤—Ç–æ-–ª–æ–≥–∏–Ω–∞
        InviteManager.init(client);
        
        return true;
    }

    static async validateToken(client, userId, token) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/auth/validate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ userId, token })
            });

            if (!response.ok) return false;
            const data = await response.json();
            return data.valid === true;
        } catch (error) {
            return false;
        }
    }

    static async registerUser(client, username, password) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/auth`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });

            const responseText = await response.text();
            let data;
            try {
                data = JSON.parse(responseText);
            } catch (e) {
                throw new Error('–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö');
            }

            if (!response.ok) {
                throw new Error(data.error || `–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: ${response.status}`);
            }

            const users = this.getAllUsers();
            users[username] = {
                username: username,
                password: password,
                userId: data.userId,
                token: data.token
            };
            this.saveAllUsers(users);
            this.saveLastUser({
                username: username,
                userId: data.userId,
                token: data.token
            });

            client.userId = data.userId;
            client.token = data.token;
            client.username = username;

            // –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º InviteManager –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
            InviteManager.init(client);
            
            return true;
        } catch (error) {
            throw error;
        }
    }

    static showAuthModal(client) {
        const users = this.getAllUsers();
        const savedUser = this.loadLastUser();
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.innerHTML = `
            <div class="modal-content">
                <h2>–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</h2>
                <div class="saved-users-list">
                    ${Object.keys(users).length === 0 
                        ? '<div class="no-users-message">–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</div>' 
                        : Object.values(users).map(u => `
                            <div class="saved-user-item" data-username="${u.username}">
                                <span>${u.username}</span>
                                <button class="remove-user-btn" data-user="${u.username}">‚úï</button>
                            </div>
                        `).join('')}
                </div>
                <input type="text" id="usernameInput" placeholder="–ù–∏–∫–Ω–µ–π–º" value="${savedUser ? savedUser.username : ''}">
                <input type="password" id="passwordInput" placeholder="–ü–∞—Ä–æ–ª—å">
                <button id="authSubmitBtn">–í–æ–π—Ç–∏</button>
                <button id="createNewUserBtn">‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ</button>
            </div>
        `;
        document.body.appendChild(modal);
        
        const usernameInput = modal.querySelector('#usernameInput');
        const passwordInput = modal.querySelector('#passwordInput');
        const submitBtn = modal.querySelector('#authSubmitBtn');

        modal.querySelectorAll('.saved-user-item').forEach(item => {
            item.addEventListener('click', () => {
                const username = item.dataset.username;
                const user = users[username];
                usernameInput.value = username;
                passwordInput.value = user.password;
                passwordInput.focus();
            });
        });

        modal.querySelectorAll('.remove-user-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const username = btn.dataset.user;
                if (confirm(`–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${username}?`)) {
                    this.removeUser(username);
                    modal.remove();
                    this.showAuthModal(client);
                }
            });
        });

        modal.querySelector('#createNewUserBtn').addEventListener('click', () => {
            usernameInput.value = '';
            passwordInput.value = '';
            usernameInput.focus();
        });

        const handleSubmit = async () => {
            const u = usernameInput.value.trim();
            const p = passwordInput.value.trim();
            if (u.length < 3 || p.length < 4) {
                alert('–ù–∏–∫ ‚Äî –æ—Ç 3, –ø–∞—Ä–æ–ª—å ‚Äî –æ—Ç 4');
                return;
            }
            try {
                const success = await this.registerUser(client, u, p);
                if (success) {
                    modal.remove();
                    
                    // –ù–û–í–û–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–µ—Ä–≤–µ—Ä—ã —á–µ—Ä–µ–∑ –∏–º–ø–æ—Ä—Ç
                    await import('./ServerManager.js').then(module => {
                        return module.default.loadServers(client);
                    });

                    // –ù–û–í–û–ï: –ü—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–π –∏–Ω–≤–∞–π—Ç –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                    const inviteApplied = await InviteManager.applyPendingInvite();
                    
                    // –ï—Å–ª–∏ –∏–Ω–≤–∞–π—Ç –±—ã–ª –ø—Ä–∏–º–µ–Ω–µ–Ω, –æ–Ω —Å–∞–º –ø–æ–∑–∞–±–æ—Ç–∏—Ç—Å—è –æ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                    if (inviteApplied) {
                        return;
                    }

                    // –°—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    if (client.inviteServerId) {
                        const serverExists = client.servers.some(s => s.id === client.inviteServerId);
                        if (serverExists) {
                            client.currentServerId = client.inviteServerId;
                            await import('./RoomManager.js').then(module => {
                                return module.default.loadRoomsForServer(client, client.inviteServerId);
                            });
                            return;
                        }
                    }

                    if (client.currentServerId) {
                        await import('./RoomManager.js').then(module => {
                            return module.default.loadRoomsForServer(client, client.currentServerId);
                        });
                    }
                    if (client.currentRoom) {
                        await client.reconnectToRoom(client.currentRoom);
                    }
                }
            } catch (error) {
                alert('–û—à–∏–±–∫–∞: ' + error.message);
            }
        };

        submitBtn.addEventListener('click', handleSubmit);
        passwordInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') handleSubmit();
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
        
        // –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º InviteManager –ø—Ä–∏ –ø–æ–∫–∞–∑–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
        InviteManager.init(client);
    }
}

export default AuthManager;


ChatManager.js:
import UIManager from './UIManager.js';

class ChatManager {
    static async loadMessages(client, roomId) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}/messages`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                if (data.messages && Array.isArray(data.messages)) {
                    data.messages.forEach(message => {
                        const username = message.username || 'Unknown';
                        UIManager.addMessage(username, message.text, message.timestamp);
                    });
                }
            }
        } catch (error) {}
    }

    static async sendMessage(client, text) {
        if (!text.trim() || !client.currentRoom) return;

        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    roomId: client.currentRoom,
                    text: text.trim(),
                    userId: client.userId
                })
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è');
            }
        } catch (error) {
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ');
        }
    }

    static setupSocketHandlers(client) {
        if (!client.socket) return;

        client.socket.on('new-message', (data) => {
            const username = data.username || 'Unknown';
            UIManager.addMessage(username, data.text, data.timestamp);
        });

        client.socket.on('message-history', (messages) => {
            messages.forEach(msg => {
                const username = msg.username || 'Unknown';
                UIManager.addMessage(username, msg.text, msg.timestamp);
            });
        });
    }
}

export default ChatManager;


InviteManager.js:
import UIManager from './UIManager.js';

class InviteManager {
    static STORAGE_KEY = 'pending_invite';
    static INVITE_CODE_REGEX = /^[a-zA-Z0-9]{4}$/;

    static init(client) {
        this.client = client;
        this.processUrlParams();
    }

    static processUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const inviteCode = params.get('invite');
        
        if (inviteCode && this.isValidInviteCode(inviteCode)) {
            this.setPendingInvite(inviteCode);
            this.cleanUrlParams();
        }
    }

    static isValidInviteCode(code) {
        return this.INVITE_CODE_REGEX.test(code);
    }

    static setPendingInvite(code) {
        localStorage.setItem(this.STORAGE_KEY, code);
    }

    static getPendingInvite() {
        return localStorage.getItem(this.STORAGE_KEY);
    }

    static clearPendingInvite() {
        localStorage.removeItem(this.STORAGE_KEY);
    }

    static cleanUrlParams() {
        const url = new URL(window.location);
        url.searchParams.delete('invite');
        window.history.replaceState({}, '', url);
    }

    static async applyPendingInvite() {
        const inviteCode = this.getPendingInvite();
        if (!inviteCode || !this.client.token) {
            return false;
        }

        try {
            const inviteInfo = await this.getInviteInfo(inviteCode);
            if (!inviteInfo) {
                this.clearPendingInvite();
                return false;
            }

            let success = false;
            if (inviteInfo.invite.targetType === 'server') {
                success = await this.joinServerByInvite(inviteInfo);
            } else if (inviteInfo.invite.targetType === 'room') {
                success = await this.joinRoomByInvite(inviteInfo);
            }

            if (success) {
                this.clearPendingInvite();
                UIManager.addMessage('System', `‚úÖ –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é —É—Å–ø–µ—à–Ω–æ`);
            }

            return success;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞:', error);
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ');
            this.clearPendingInvite();
            return false;
        }
    }

    static async getInviteInfo(inviteCode) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites/${inviteCode}`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–Ω–≤–∞–π—Ç–µ:', error);
            throw error;
        }
    }

    static async joinServerByInvite(inviteInfo) {
        try {
            const { invite } = inviteInfo;
            
            const serverExists = this.client.servers.some(s => s.id === invite.targetId);
            if (serverExists) {
                this.client.currentServerId = invite.targetId;
                UIManager.addMessage('System', `–í—ã —É–∂–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω—ã –∫ —Å–µ—Ä–≤–µ—Ä—É "${invite.targetInfo.name}"`);
                return true;
            }

            const response = await fetch(`${this.client.API_SERVER_URL}/api/servers/${invite.targetId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    userId: this.client.userId,
                    token: this.client.token
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `–û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ${response.status}`);
            }

            const data = await response.json();
            
            const serverExistsInList = this.client.servers.some(s => s.id === data.server.id);
            if (!serverExistsInList) {
                this.client.servers.push(data.server);
            }
            
            this.client.currentServerId = data.server.id;
            this.client.currentServer = data.server;

            UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É "${data.server.name}" –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é`);
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–º–Ω–∞—Ç—ã —Å–µ—Ä–≤–µ—Ä–∞
            const RoomManager = await import('./RoomManager.js').then(module => module.default);
            await RoomManager.loadRoomsForServer(this.client, data.server.id);

            return true;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É –ø–æ –∏–Ω–≤–∞–π—Ç—É:', error);
            UIManager.showError(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É: ${error.message}`);
            return false;
        }
    }

    static async joinRoomByInvite(inviteInfo) {
        try {
            const { invite } = inviteInfo;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –∏–Ω–≤–∞–π—Ç–∞, –∞ –Ω–µ –¥–µ–ª–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å
            if (!invite.targetInfo || !invite.targetInfo.serverId) {
                throw new Error('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ–º–Ω–∞—Ç–µ –≤ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–∏');
            }

            const serverId = invite.targetInfo.serverId;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω—ã –ª–∏ –º—ã –∫ —Å–µ—Ä–≤–µ—Ä—É
            const serverExists = this.client.servers.some(s => s.id === serverId);
            if (!serverExists) {
                // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É
                const serverJoinSuccess = await this.joinServerByInvite({
                    invite: {
                        ...invite,
                        targetId: serverId,
                        targetType: 'server',
                        targetInfo: { name: invite.targetInfo.serverName }
                    }
                });
                
                if (!serverJoinSuccess) {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É –∫–æ–º–Ω–∞—Ç—ã');
                }
            }

            this.client.currentServerId = serverId;
            this.client.currentRoom = invite.targetId;

            // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–º–Ω–∞—Ç—ã —Å–µ—Ä–≤–µ—Ä–∞
            const RoomManager = await import('./RoomManager.js').then(module => module.default);
            await RoomManager.loadRoomsForServer(this.client, serverId);
            
            // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ
            await RoomManager.joinRoom(this.client, invite.targetId);

            UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ "${invite.targetInfo.name}" –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é`);
            this.client.currentRoom = invite.targetId;
            return true;
        } catch (error) {
            //console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –∫–æ–º–Ω–∞—Ç–µ –ø–æ –∏–Ω–≤–∞–π—Ç—É:', error);
            return false;
        }
    }

    static async createServerInvite(serverId, expiresInHours = 168) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    targetId: serverId,
                    targetType: 'server',
                    expiresInHours
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invite;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞:', error);
            throw error;
        }
    }

    static async createRoomInvite(roomId, expiresInHours = 168) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    targetId: roomId,
                    targetType: 'room',
                    expiresInHours
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invite;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞ –∫–æ–º–Ω–∞—Ç—ã:', error);
            throw error;
        }
    }

    static async getServerInvites(serverId) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/servers/${serverId}/invites`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invites;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω–≤–∞–π—Ç–æ–≤ —Å–µ—Ä–≤–µ—Ä–∞:', error);
            throw error;
        }
    }

    static async getRoomInvites(roomId) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/rooms/${roomId}/invites`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invites;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω–≤–∞–π—Ç–æ–≤ –∫–æ–º–Ω–∞—Ç—ã:', error);
            throw error;
        }
    }

    static generateInviteLink(code) {
        return `https://ns.fiber-gate.ru/${code}`;
    }

    static copyInviteLink(code) {
        const link = this.generateInviteLink(code);
        navigator.clipboard.writeText(link)
            .then(() => {
                UIManager.showError('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
            })
            .catch(err => {
                console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏:', err);
                UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É');
            });
    }
}

export default InviteManager;


MediaManager.js:
// MediaManager.js
import UIManager from './UIManager.js';
import MembersManager from './MembersManager.js';

class MediaManager {
    static async connect(client, roomId, mediaData) {
        console.log('MediaManager connecting to room:', roomId);
        try {
            if (typeof mediasoupClient === 'undefined') {
                throw new Error('–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ mediasoup-client –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
            }
            client.device = new mediasoupClient.Device();
            await client.device.load({ routerRtpCapabilities: mediaData.rtpCapabilities });
            await this.createTransports(client, mediaData);
            this.startKeepAlive(client, roomId);
            client.isConnected = true;
            client.isMicActive = false;
            client.existingProducers = new Set();
            client.consumers = new Map();
            await this.requestCurrentProducers(client, roomId);
            console.log('MediaManager connected successfully');
        } catch (error) {
            console.error('MediaManager connection failed:', error);
            throw new Error(`Media connection failed: ${error.message}`);
        }
    }

    static async enableMicrophone(client) {
        console.log('Enabling microphone for client:', client.clientID);
        if (client.audioProducer && client.audioProducer.track) {
            if (client.audioProducer.closed || (client.sendTransport && client.sendTransport.closed)) {
                console.log('Audio producer or its transport is closed, restarting microphone...');
                await MediaManager.stopMicrophone(client, false);
                await MediaManager.startMicrophone(client);
                return true;
            }
            client.audioProducer.track.enabled = true;
            client.isMicActive = true;
            console.log('Microphone enabled successfully');
            return true;
        } else {
            console.log('No audio producer or track found, starting microphone...');
            await MediaManager.startMicrophone(client);
            return true;
        }
    }

    static async disableMicrophone(client) {
        console.log('Disabling microphone for client:', client.clientID);
        if (client.audioProducer && client.audioProducer.track) {
            client.audioProducer.track.enabled = false;
            client.isMicActive = false;
            console.log('Microphone disabled successfully');
            return true;
        } else {
            console.log('No audio producer or track found, cannot disable');
            return false;
        }
    }

    static async createTransports(client, mediaData) {
        console.log('Creating transports for client:', client.clientID);
        try {
            if (!client.sendTransport) {
                console.log('Creating send transport');
                client.sendTransport = client.device.createSendTransport({
                    id: mediaData.sendTransport.id,
                    iceParameters: mediaData.sendTransport.iceParameters,
                    iceCandidates: mediaData.sendTransport.iceCandidates,
                    dtlsParameters: mediaData.sendTransport.dtlsParameters
                });
                this.setupSendTransportHandlers(client);
            } else {
                console.log('Send transport already exists, reusing');
            }
            if (!client.recvTransport) {
                console.log('Creating receive transport');
                client.recvTransport = client.device.createRecvTransport({
                    id: mediaData.recvTransport.id,
                    iceParameters: mediaData.recvTransport.iceParameters,
                    iceCandidates: mediaData.recvTransport.iceCandidates,
                    dtlsParameters: mediaData.recvTransport.dtlsParameters
                });
                this.setupRecvTransportHandlers(client);
            } else {
                console.log('Receive transport already exists, reusing');
            }
        } catch (error) {
            console.error('Error creating transports:', error);
            throw error;
        }
    }

    static setupSendTransportHandlers(client) {
        console.log('Setting up send transport handlers');
        client.sendTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
            console.log('Send transport connecting...');
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                await fetch(`${client.API_SERVER_URL}/api/media/transport/connect`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.sendTransport.id,
                        dtlsParameters: dtlsParameters
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                console.log('Send transport connected successfully');
                callback();
            } catch (error) {
                console.error('Send transport connection failed:', error);
                errback(error);
            }
        });

        client.sendTransport.on('produce', async (parameters, callback, errback) => {
            console.log('Producing media:', parameters.kind);
            try {
                const response = await fetch(`${client.API_SERVER_URL}/api/media/produce`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.sendTransport.id,
                        kind: parameters.kind,
                        rtpParameters: parameters.rtpParameters,
                        clientId: client.clientID,
                        roomId: client.currentRoom
                    })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Produce failed:', response.status, errorText);
                    throw new Error(`HTTP error: ${response.status}`);
                }
                const data = await response.json();
                console.log('Media produced successfully:', data.producerId);
                callback({ id: data.producerId });
            } catch (error) {
                console.error('Produce failed:', error);
                errback(error);
            }
        });
    }

    static setupRecvTransportHandlers(client) {
        console.log('Setting up receive transport handlers');
        client.recvTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
            console.log('Receive transport connecting...');
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                await fetch(`${client.API_SERVER_URL}/api/media/transport/connect`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.recvTransport.id,
                        dtlsParameters: dtlsParameters
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                console.log('Receive transport connected successfully');
                callback();
            } catch (error) {
                console.error('Receive transport connection failed:', error);
                errback(error);
            }
        });
    }

    static async startMicrophone(client) {
        console.log('Starting microphone for client:', client.clientID);
        try {
            if (!client.sendTransport) {
                console.error('Send transport is not initialized');
                throw new Error('Send transport –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
            }
            const constraints = {
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    channelCount: 1,
                    latency: 0.1,
                    sampleSize: 16
                }
            };
            client.stream = await navigator.mediaDevices.getUserMedia(constraints);
            const track = client.stream.getAudioTracks()[0];
            client.audioProducer = await client.sendTransport.produce({
                track,
                encodings: [
                    {
                        maxBitrate: 24000,
                        dtx: true
                    }
                ],
                appData: {
                    clientID: client.clientID,
                    roomId: client.currentRoom
                }
            });
            client.isMicActive = true;
            console.log('Microphone started successfully');
            if (client.socket && client.audioProducer) {
                client.socket.emit('new-producer-notification', {
                    roomId: client.currentRoom,
                    producerId: client.audioProducer.id,
                    clientID: client.clientID,
                    userId: client.userId,
                    kind: 'audio'
                });
            }
        } catch (error) {
            console.error('Microphone start failed:', error);
            if (client.stream) {
                client.stream.getTracks().forEach(track => track.stop());
                client.stream = null;
            }
            throw error;
        }
    }

    static async stopMicrophone(client, closeTransport = true) {
        console.log('Stopping microphone for client:', client.clientID);
        try {
            if (client.audioProducer) {
                try {
                    await fetch(`${client.API_SERVER_URL}/api/media/producer/close`, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${client.token}`
                        },
                        body: JSON.stringify({
                            producerId: client.audioProducer.id
                        })
                    });
                } catch (error) {
                    console.warn('Error closing producer on server:', error);
                }
                client.audioProducer.close();
                client.audioProducer = null;
            }
            if (client.stream) {
                client.stream.getTracks().forEach(track => track.stop());
                client.stream = null;
            }
            if (closeTransport && client.sendTransport) {
                try {
                    client.sendTransport.close();
                } catch (error) {
                    console.warn('Error closing send transport:', error);
                }
                client.sendTransport = null;
            }
            client.isMicActive = false;
            console.log('Microphone stopped successfully');
        } catch (error) {
            console.error('Microphone stop failed:', error);
            throw new Error(`Microphone stop failed: ${error.message}`);
        }
    }

    static startKeepAlive(client, roomId) {
        console.log('Starting keep-alive for client:', client.clientID);
        if (client.keepAliveInterval) {
            clearInterval(client.keepAliveInterval);
        }
        client.keepAliveInterval = setInterval(() => {
            fetch(`${client.API_SERVER_URL}/api/media/health`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    clientId: client.clientID,
                    roomId: roomId
                })
            }).catch(() => {
                console.warn('Keep-alive request failed');
            });
        }, 10000);
    }

    static async requestCurrentProducers(client, roomId) {
        console.log('Requesting current producers for room:', roomId);
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/media/rooms/${roomId}/producers`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                console.warn('Failed to get producers list:', response.status);
                return;
            }
            const data = await response.json();
            if (!data || !data.producers || !Array.isArray(data.producers)) {
                console.warn('Invalid producers data received:', data);
                return;
            }
            console.log('Found', data.producers.length, 'producers in room');

            for (const producer of data.producers) {
                if (producer.clientID !== client.clientID) {
                    await client.ensureConsumer(producer.id, producer);
                    // üîπ –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ ensureConsumer ‚Äî –∏—â–µ–º userId –ø–æ clientId
                    if (!window.producerUserMap) window.producerUserMap = new Map();
                    const members = MembersManager.getMembers();
                    const member = members.find(m => m.clientId === producer.clientID);
                    if (member?.userId) {
                        window.producerUserMap.set(producer.id, member.userId);
                        UIManager.showVolumeSliderByUserId(producer.id, member.userId);
                    }
                } else {
                    client.consumerState.set(producer.id, { status: 'active', consumer: null, lastError: null });
                    console.log('Own producer found in initial list:', producer.id);
                }
            }
        } catch (error) {
            console.error('Error requesting current producers:', error);
        }
    }

    static async createConsumer(client, producerId, retries = 3, producerData = {}) {
        console.group('üéØ MediaManager.createConsumer - START');
        console.log('üîπ producerId:', producerId);
        console.log('üîπ producerData:', producerData);
        console.log('üîπ client.clientID:', client.clientID);
        console.groupEnd();

        if (client.audioProducer && client.audioProducer.id === producerId) {
            console.log('‚ùå Skipping own producer');
            throw new Error('Cannot consume own producer');
        }

        if (client.consumers.has(producerId)) {
            console.log('‚ÑπÔ∏è Consumer already exists for producer:', producerId);
            const existingConsumer = client.consumers.get(producerId);
            if (existingConsumer.closed || existingConsumer.transportClosed) {
                console.log('üîÑ Existing consumer is closed, creating new one');
                client.consumers.delete(producerId);
            } else {
                return existingConsumer;
            }
        }

        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                console.group(`üîÑ Creating consumer attempt ${attempt}/${retries}`);
                console.log('üîπ producerId:', producerId);
                const response = await fetch(`${client.API_SERVER_URL}/api/media/consume`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        producerId: producerId,
                        rtpCapabilities: client.device.rtpCapabilities,
                        transportId: client.recvTransport.id,
                        clientId: client.clientID
                    })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå HTTP error:', response.status, errorText);
                    if (response.status === 400 && errorText.includes('own audio')) {
                        throw new Error('Cannot consume own audio');
                    }
                    throw new Error(`HTTP error: ${response.status}`);
                }
                const data = await response.json();
                console.log('üîπ Server response data:', data);
                if (!data || !data.id) {
                    console.error('‚ùå Invalid consumer data received:', data);
                    throw new Error('Invalid consumer data received');
                }
                console.log('‚úÖ Consumer data received from server:', data.id);

                const consumer = await client.recvTransport.consume({
                    id: data.id,
                    producerId: data.producerId,
                    kind: data.kind,
                    rtpParameters: data.rtpParameters
                });
                client.consumers.set(producerId, consumer);

                let audioElement = window.audioElements?.get(producerId);
                if (!audioElement || audioElement.closed) {
                    audioElement = new Audio();
                    audioElement.id = `audio-${producerId}`;
                    audioElement.autoplay = true;
                    audioElement.volume = 1.0;
                    audioElement.style.display = 'none';
                    if (!window.audioElements) window.audioElements = new Map();
                    window.audioElements.set(producerId, audioElement);
                    document.body.appendChild(audioElement);
                    console.log('üéµ New audio element created for producer:', producerId);
                }

                const stream = new MediaStream([consumer.track.clone()]);
                audioElement.srcObject = stream;

// üîπ –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞–ø–ø–∏–Ω–≥–∏ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ syncVolumeSliders
if (producerData.userId) {
    if (!window.producerUserMap) window.producerUserMap = new Map();
    window.producerUserMap.set(data.producerId, producerData.userId);
} else if (producerData.clientID) {
    if (!window.producerClientMap) window.producerClientMap = new Map();
    window.producerClientMap.set(data.producerId, producerData.clientID);
}
                consumer.on('transportclose', () => {
                    console.log('üîå Consumer transport closed:', consumer.id);
                    consumer.transportClosed = true;
                });
                consumer.on('trackended', () => {
                    console.log('üîá Consumer track ended:', consumer.id);
                });

                console.log('‚úÖ Consumer created successfully:', data.id);
                console.groupEnd();
                return consumer;
            } catch (error) {
                console.error(`‚ùå Error creating consumer (attempt ${attempt}/${retries}):`, error);
                if (error.message.includes('consume own') || 
                    error.message.includes('own audio') || 
                    error.message.includes('400') ||
                    error.message.includes('Cannot consume own')) {
                    client.existingProducers.add(producerId);
                    console.log('üîá Added to excluded producers:', producerId);
                    throw error;
                }
                if (attempt === retries) {
                    console.groupEnd();
                    throw error;
                }
                const delay = Math.pow(2, attempt) * 1000;
                console.log(`‚è≥ Waiting ${delay}ms before next attempt...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                console.groupEnd();
            }
        }
    }

    static disconnect(client) {
        console.log('Disconnecting media for client:', client.clientID);
        if (client.keepAliveInterval) {
            clearInterval(client.keepAliveInterval);
            client.keepAliveInterval = null;
        }
        if (client.isMicActive) {
            this.stopMicrophone(client).catch(() => {
                console.warn('Error stopping microphone during disconnect');
            });
        }
        if (client.sendTransport) {
            try {
                client.sendTransport.close();
            } catch (error) {
                console.warn('Error closing send transport:', error);
            }
            client.sendTransport = null;
        }
        if (client.recvTransport) {
            try {
                client.recvTransport.close();
            } catch (error) {
                console.warn('Error closing receive transport:', error);
            }
            client.recvTransport = null;
        }
        client.consumers.forEach(consumer => {
            try {
                consumer.close();
            } catch (error) {
                console.warn('Error closing consumer:', error);
            }
        });
        client.consumers.clear();
        if (window.audioElements) {
            window.audioElements.forEach(audio => {
                try {
                    audio.pause();
                    audio.srcObject = null;
                    audio.remove();
                } catch (error) {
                    console.warn('Error cleaning up audio element:', error);
                }
            });
            window.audioElements.clear();
        }
        client.device = null;
        client.isConnected = false;
        client.existingProducers.clear();
        console.log('Media disconnected successfully');
    }

    static async handleNewProducer(client, producerData) {
        console.group('üî¥üî¥üî¥ [DEBUG] MEDIA MANAGER: handleNewProducer');
        console.log('üéØ [DEBUG] CALLED handleNewProducer with ', JSON.stringify(producerData, null, 2));
        console.log('üéØ [DEBUG] CLIENT STATE - clientID:', client.clientID);
        console.log('üéØ [DEBUG] CLIENT STATE - existingProducers (BEFORE):', Array.from(client.existingProducers));
        console.log('üéØ [DEBUG] CHECK: Is this my own producer?', producerData.clientID === client.clientID);
        console.log('üéØ [DEBUG] CHECK: Is producer already in existingProducers?', client.existingProducers.has(producerData.producerId));
        console.groupEnd();

        console.log('Handling new producer notification:', producerData);
        if (producerData.clientID !== client.clientID) {
            console.log('üéß [DEBUG] MediaManager: Attempting to create consumer for producer:', producerData.producerId);
            try {
                await this.createConsumer(client, producerData.producerId);
                client.existingProducers.add(producerData.producerId);
                console.log('‚úÖ [DEBUG] MediaManager: Consumer created and producerId added to existingProducers:', producerData.producerId);
            } catch (error) {
                console.error('‚ùå Error creating consumer from notification:', error);
                console.log('‚ùå [DEBUG] MediaManager: Consumer creation FAILED for producer:', producerData.producerId);
            }
        } else {
            console.log('üîá [DEBUG] MediaManager: Ignoring own producer:', producerData.producerId);
        }

        console.group('üî¥üî¥üî¥ [DEBUG] AFTER MediaManager.handleNewProducer');
        console.log('üéØ [DEBUG] CLIENT STATE - existingProducers (AFTER):', Array.from(client.existingProducers));
        console.groupEnd();
    }
}

export default MediaManager;


MembersManager.js:
import UIManager from './UIManager.js';

class MembersManager {
    static members = new Map();

static updateMember(userId, updates) {
    if (this.members.has(userId)) {
        // üî¥üî¥üî¥ –ê–ì–†–ï–°–°–ò–í–ù–´–ô –î–ï–ë–ê–ì: –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–ï–†–ï–î –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
        console.group('üî¥üî¥üî¥ [DEBUG] MEMBERS MANAGER: updateMember CALLED');
        console.log('üéØ [DEBUG] TARGET userId:', userId);
        console.log('üéØ [DEBUG] UPDATES received:', JSON.stringify(updates, null, 2));
        console.log('üéØ [DEBUG] STATE BEFORE update:', JSON.stringify(this.members.get(userId), null, 2));
        console.groupEnd();

        const member = { ...this.members.get(userId), ...updates };
        this.members.set(userId, member);

        // üî¥üî¥üî¥ –ê–ì–†–ï–°–ò–í–ù–´–ô –î–ï–ë–ê–ì: –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–û–°–õ–ï –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        console.group('üî¥üî¥üî¥ [DEBUG] MEMBERS MANAGER: updateMember FINISHED');
        console.log('üéØ [DEBUG] STATE AFTER update:', JSON.stringify(this.members.get(userId), null, 2));
        console.groupEnd();

        UIManager.updateMembersList(Array.from(this.members.values()));
        // –û–±–Ω–æ–≤–ª—è–µ–º UI –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        UIManager.updateMemberMicState(userId, updates.isMicActive);
    }
}

// modules/MembersManager.js
static addMember(memberData) {
    if (!memberData.userId) {
        console.error('Member data must contain userId');
        return;
    }
    console.group('üî¥üî¥üî¥ [DEBUG] MEMBERS MANAGER: addMember CALLED');
    console.log('üéØ [DEBUG] RAW INPUT memberData:', JSON.stringify(memberData, null, 2));
    console.groupEnd();

    // üî¥üî¥üî¥ –ö–õ–Æ–ß–ï–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï:
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
    const existingMember = this.members.get(memberData.userId);
    let isCurrentlyOnline = true; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é true –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

    if (existingMember) {
        isCurrentlyOnline = existingMember.isOnline;
        // üî¥üî¥üî¥ –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ó–ê–©–ò–¢–ê: –ï—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –í–°–ï–ì–î–ê —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ —Å—Ç–∞—Ç—É—Å –∫–∞–∫ true.
        if (this.client && memberData.userId === this.client.userId) {
            isCurrentlyOnline = true;
        }
    }

    const processedMemberData = {
        userId: memberData.userId,
        username: memberData.username || `User_${memberData.userId.substr(0, 8)}`,
        isMicActive: memberData.isMicActive || false,
        isOnline: memberData.isOnline !== undefined ? memberData.isOnline : isCurrentlyOnline,
        clientId: memberData.clientId || null
    };

    console.group('üî¥üî¥üî¥ [DEBUG] MEMBERS MANAGER: addMember PROCESSED');
    console.log('üéØ [DEBUG] PROCESSED memberData:', JSON.stringify(processedMemberData, null, 2));
    console.groupEnd();

    this.members.set(processedMemberData.userId, processedMemberData);
    UIManager.updateMembersList(Array.from(this.members.values()));
}
    static removeMember(userId) {
        if (this.members.has(userId)) {
            this.members.delete(userId);
            UIManager.updateMembersList(Array.from(this.members.values()));
        }
    }

    static clearMembers() {
        this.members.clear();
        UIManager.updateMembersList([]);
    }

// modules/MembersManager.js

static updateAllMembers(members) {
    console.log('üéØ [MEMBERS MANAGER] updateAllMembers called. Replacing entire members list.');
    console.log('üéØ [MEMBERS MANAGER] New members list (in order):', members.map(m => `${m.username} (${m.isOnline ? 'ONLINE' : 'OFFLINE'})`));
    
    // ‚úÖ 1. –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é –∫–∞—Ä—Ç—É
    this.members.clear();
    
    // ‚úÖ 2. –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–∞—Ä—Ç—É –≤ –¢–û–ß–ù–û–ú –ø–æ—Ä—è–¥–∫–µ, –≤ –∫–æ—Ç–æ—Ä–æ–º –ø—Ä–∏—à–ª–∏ –¥–∞–Ω–Ω—ã–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
    members.forEach(member => {
        this.members.set(member.userId, member);
    });
    
    // ‚úÖ 3. –ì–õ–ê–í–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º –≤ UI –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤ `members`, –∞ –Ω–µ Array.from(this.members.values())
    // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ø–æ—Ä—è–¥–æ–∫ –≤ UI –±—É–¥–µ—Ç –¢–û–ß–ù–û —Ç–∞–∫–∏–º –∂–µ, –∫–∞–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.
    UIManager.updateMembersList(members); // <-- –ü–µ—Ä–µ–¥–∞–µ–º `members`, –∞ –Ω–µ `Array.from(this.members.values())`
    
    console.log('‚úÖ [MEMBERS MANAGER] Members list fully replaced and rendered in correct order.');
}

static setupSocketHandlers(client) {
    if (!client.socket) return;

    client.socket.on('room-participants', (participants) => {
        this.updateAllMembers(participants);
    });

    // --- –ò–ó–ú–ï–ù–ï–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö user-joined ---
    client.socket.on('user-joined', async (user) => {
        console.log('User joined (ONLINE):', user);
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        if (this.members.has(user.userId)) {
            // –ï—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –¥–∞–Ω–Ω—ã–µ –∏ —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
            this.updateMember(user.userId, { 
                ...user,
                isOnline: true 
            });
        } else {
            // –ï—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            this.addMember({
                ...user,
                isOnline: true
            });
        }
        UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user.username} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ`);
    });

    // --- –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö user-left ---
    client.socket.on('user-left', async (data) => {
        console.log('User left:', data);
        // –ü–æ–ª—É—á–∞–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å–ø–∏—Å–∫–∞, —á—Ç–æ–±—ã –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
        const member = MembersManager.getMember(data.userId);
        if (member) {
            UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${member.username} –ø–æ–∫–∏–Ω—É–ª –∫–æ–º–Ω–∞—Ç—É`);
        } else {
            UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–∫–∏–Ω—É–ª –∫–æ–º–Ω–∞—Ç—É`);
        }
    });

    client.socket.on('user-mic-state', (data) => {
        if (data.userId) {
            this.updateMember(data.userId, { isMicActive: data.isActive });
        } else if (data.clientID) {
            // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ clientID
            const members = Array.from(this.members.values());
            const member = members.find(m => m.clientId === data.clientID);
            if (member) {
                this.updateMember(member.userId, { isMicActive: data.isActive });
            }
        }
    });
}


    static setupSSEHandlers() {
        console.log('SSE handlers for members are setup in TextChatManager');
    }

    static getMembers() {
        return Array.from(this.members.values());
    }

    static getMember(userId) {
        return this.members.get(userId);
    }

    static isCurrentUser(client, userId) {
        return client.userId === userId;
    }

    static initializeRoomMembers(client, participants) {
        console.log('Initializing room members with:', participants);
        this.clearMembers();
        participants.forEach(participant => this.addMember(participant));
    }
}

export default MembersManager;


RoomManager.js:
import UIManager from './UIManager.js';
import MediaManager from './MediaManager.js';
import TextChatManager from './TextChatManager.js';
import MembersManager from './MembersManager.js';
import InviteManager from './InviteManager.js';

class RoomManager {
  static async loadRoomsForServer(client, serverId) {
    try {
      client.currentServerId = serverId;
      client.currentServer = client.servers.find(s => s.id === serverId) || null;
      UIManager.updateStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–Ω–∞—Ç...', 'connecting');
      
      const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/rooms`, {
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–º–Ω–∞—Ç—ã: ${errorData.error || res.statusText}`);
      }
      
      const data = await res.json();
      if (!data || !Array.isArray(data.rooms)) {
        throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
      }
      
      // –°–û–•–†–ê–ù–Ø–ï–ú –ö–û–ú–ù–ê–¢–´ –í –ö–õ–ò–ï–ù–¢–ï
      client.rooms = data.rooms;
      
      this.renderRooms(client, data.rooms);
      UIManager.updateStatus('–ö–æ–º–Ω–∞—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã', 'normal');
      
    } catch (error) {
      UIManager.updateStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–º–Ω–∞—Ç', 'error');
      UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–º–Ω–∞—Ç—ã: ' + error.message);
    }
  }

  static async joinRoom(client, roomId) {
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}/join`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(errorData.error || `–û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ${res.status}`);
      }
      
      const data = await res.json();
      client.currentRoom = roomId;
      client.roomType = 'voice';
      
      try {
        await MediaManager.connect(client, roomId, data.mediaData);
        UIManager.updateRoomUI(client);
        await MediaManager.startConsumingProducers(client);
      } catch (mediaError) {
        UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ' + mediaError.message);
        throw mediaError;
      }
      
      UIManager.updateRoomUI(client);
      TextChatManager.joinTextRoom(client, roomId);
      await TextChatManager.loadMessages(client, roomId);
      
      UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ`);
      return true;
    } catch (error) {
      //UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ' + error.message);
      throw error;
    }
  }

  static async leaveRoom(client) {
    if (!client.currentRoom) return;
    
    try {
      if (client.isConnected) {
        MediaManager.disconnect(client);
      }
      
      await fetch(`${client.API_SERVER_URL}/api/rooms/${client.currentRoom}/leave`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      MembersManager.clearMembers();
      
      client.currentRoom = null;
      client.roomType = null;
      
      UIManager.updateRoomUI(client);
      UIManager.addMessage('System', `‚úÖ –í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –∫–æ–º–Ω–∞—Ç—É`);
      return true;
    } catch (error) {
      UIManager.showError('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∏–¥–∞–Ω–∏–∏ –∫–æ–º–Ω–∞—Ç—ã: ' + error.message);
      return false;
    }
  }

  static async createRoom(client, serverId, name) {
    if (!name || name.length < 3) {
      alert('–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 —Å–∏–º–≤–æ–ª–æ–≤');
      return;
    }
    
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${client.token}`
        },
        body: JSON.stringify({
          name: name.trim(),
          serverId: serverId,
          type: 'voice',
          userId: client.userId,
          token: client.token
        })
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        const errorMessage = errorData.error || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É';
        if (errorMessage.includes('—É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç')) {
          alert(`–û—à–∏–±–∫–∞: ${errorMessage}. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.`);
        } else {
          throw new Error(errorMessage);
        }
        return;
      }
      
      const data = await res.json();
      const roomData = data.room;
      
      if (client.currentServerId === serverId) {
        await this.loadRoomsForServer(client, serverId);
      }
      
      UIManager.addMessage('System', `‚úÖ –°–æ–∑–¥–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞ "${name}"`);
    } catch (error) {
      alert('–û—à–∏–±–∫–∞: ' + error.message);
    }
  }

  static async createRoomInvite(client, roomId) {
    try {
      const invite = await InviteManager.createRoomInvite(roomId);
      
      if (invite) {
        const inviteLink = InviteManager.generateInviteLink(invite.code);
        
        UIManager.openModal('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ', `
          <p>–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–ª—è –∫–æ–º–Ω–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–æ!</p>
          <div class="invite-link-container">
            <input type="text" id="inviteLinkInput" value="${inviteLink}" readonly>
            <button onclick="navigator.clipboard.writeText('${inviteLink}').then(() => alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!'))">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
          </div>
          <p>–°—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –¥–æ: ${new Date(invite.expiresAt).toLocaleDateString()}</p>
        `, () => {
          UIManager.closeModal();
        });
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞ –∫–æ–º–Ω–∞—Ç—ã:', error);
      UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ: ' + error.message);
    }
  }

  static async copyRoomInviteLink(client, roomId) {
    try {
      const invites = await InviteManager.getRoomInvites(roomId);
      
      if (invites && invites.length > 0) {
        const activeInvite = invites.find(invite => new Date(invite.expiresAt) > new Date());
        
        if (activeInvite) {
          InviteManager.copyInviteLink(activeInvite.code);
          return;
        }
      }
      
      const invite = await InviteManager.createRoomInvite(roomId);
      if (invite) {
        InviteManager.copyInviteLink(invite.code);
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –∏–Ω–≤–∞–π—Ç–∞ –∫–æ–º–Ω–∞—Ç—ã:', error);
      UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è');
    }
  }

  static async deleteRoom(client, roomId) {
    if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –∫–æ–º–Ω–∞—Ç—É?')) return;
    
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(errorData.error || '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É');
      }
      
      if (client.currentServerId) {
        await this.loadRoomsForServer(client, client.currentServerId);
      }
      
      if (client.currentRoom === roomId) {
        await this.leaveRoom(client);
      }
      
      UIManager.addMessage('System', `‚úÖ –ö–æ–º–Ω–∞—Ç–∞ —É–¥–∞–ª–µ–Ω–∞`);
    } catch (error) {
      UIManager.showError('–û—à–∏–±–∫–∞: ' + error.message);
    }
  }

  static async reconnectToRoom(client, roomId) {
    try {
      UIManager.addMessage('System', '–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ...');
      
      client.wasMicActiveBeforeReconnect = client.isMicActive;
      
      if (client.isMicActive && client.mediaData) {
        await MediaManager.stopMicrophone(client);
      }
      
      await this.leaveRoom(client);
      
      client.isReconnecting = true;
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const result = await this.joinRoom(client, roomId);
      
      client.isReconnecting = false;
      
      if (client.wasMicActiveBeforeReconnect && client.mediaData) {
        setTimeout(async () => {
          try {
            await MediaManager.startMicrophone(client);
            client.wasMicActiveBeforeReconnect = false;
          } catch (error) {
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω –ø–æ—Å–ª–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
          }
        }, 1000);
      }
      
      return result;
    } catch (error) {
      client.isReconnecting = false;
      UIManager.addMessage('System', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
      throw error;
    }
  }

  static renderRooms(client, rooms) {
    const roomsList = document.querySelector('.rooms-list');
    if (!roomsList) return;

    roomsList.innerHTML = '';
    
    rooms.forEach(room => {
      const roomElement = document.createElement('div');
      roomElement.className = 'room-item';
      roomElement.dataset.room = room.id;
      
      const isOwner = room.ownerId === client.userId;
      const isMember = client.currentServer?.members?.includes(client.userId);
      
      roomElement.innerHTML = `üîä ${room.name} ${isOwner ? '<span class="owner-badge">(–í—ã)</span>' : ''}`;
      


roomElement.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (client.currentRoom === room.id) {
        return;
    }

    // üîä –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ autoplay –Ω–∞ iOS —á–µ—Ä–µ–∑ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–µ –∑–≤—É–∫–∞
    try {
        const unlockAudio = new Audio('/sounds/room-join.mp3'); // ‚Üê –ø—É—Ç—å –∫ –≤–∞—à–µ–º—É —Ñ–∞–π–ª—É
        unlockAudio.volume = 0.5; // –ø–æ—á—Ç–∏ —Ç–∏—Ö–æ, –Ω–æ –Ω–µ 0 (–∏–Ω–∞—á–µ Safari –º–æ–∂–µ—Ç –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å)
        await unlockAudio.play();
        console.log('‚úÖ Audio unlock successful on iOS');
    } catch (err) {
        console.warn('üîá Audio unlock failed (likely not iOS or no user gesture):', err);
        // –ù–∞ iOS –±–µ–∑ –∂–µ—Å—Ç–∞ play() –≤—ã–±—Ä–æ—Å–∏—Ç –æ—à–∏–±–∫—É ‚Äî —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.
        // –ù–æ –µ—Å–ª–∏ –∫–ª–∏–∫ –±—ã–ª ‚Äî –∑–≤—É–∫ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–∏–≥—Ä–∞—Ç—å—Å—è.
    }

    try {
        await client.joinRoom(room.id);
        localStorage.setItem('lastRoomId', room.id);
        localStorage.setItem('lastServerId', client.currentServerId);
    } catch (error) {
        console.error('Error joining room:', error);
        UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ' + error.message);
    }
});

      if (isMember) {
        const actionButtons = document.createElement('div');
        actionButtons.className = 'room-actions';
        
        const shareBtn = document.createElement('button');
        shareBtn.className = 'room-action-btn';
        shareBtn.innerHTML = 'üìã';
        shareBtn.title = '–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –∫–æ–º–Ω–∞—Ç—É';
        shareBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try {
            const invite = await InviteManager.createRoomInvite(room.id);
            const inviteLink = InviteManager.generateInviteLink(invite.code);
            
            await navigator.clipboard.writeText(inviteLink);
            UIManager.showError('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
          } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏:', error);
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É');
          }
        });
        
        actionButtons.appendChild(shareBtn);
        
        if (isOwner) {
          const inviteBtn = document.createElement('button');
          inviteBtn.className = 'room-action-btn';
          //inviteBtn.innerHTML = 'üîó';
          inviteBtn.title = '–°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ';
          inviteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.createRoomInvite(client, room.id);
          });
          
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'room-action-btn';
          deleteBtn.innerHTML = '‚úï';
          deleteBtn.title = '–£–¥–∞–ª–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteRoom(client, room.id);
          });
          
          actionButtons.appendChild(inviteBtn);
          actionButtons.appendChild(deleteBtn);
        }
        
        roomElement.appendChild(actionButtons);
      }
      
      roomsList.appendChild(roomElement);
    });
  }
}

export default RoomManager;


ServerManager.js:
import UIManager from './UIManager.js';
import RoomManager from './RoomManager.js';
import InviteManager from './InviteManager.js';

class ServerManager {
    static cachedServers = null;
    static lastUpdateTime = 0;
    static CACHE_DURATION = 30000; // 30 —Å–µ–∫—É–Ω–¥ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è

    static getLocalStorageKey(client) {
        return client.userId ? `voiceChatServers_${client.userId}` : null;
    }

    static saveServersToLocalStorage(client) {
        if (!client.userId) return;
        const key = this.getLocalStorageKey(client);
        const serversData = {
            servers: client.servers,
            timestamp: Date.now()
        };
        localStorage.setItem(key, JSON.stringify(serversData));
    }

    static loadServersFromLocalStorage(client) {
        if (!client.userId) return [];
        const key = this.getLocalStorageKey(client);
        const data = localStorage.getItem(key);
        if (data) {
            try {
                const serversData = JSON.parse(data);
                return serversData.servers || [];
            } catch (e) {
                return [];
            }
        }
        return [];
    }

    static async loadServers(client, forceUpdate = false) {
        try {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
            const now = Date.now();
            if (!forceUpdate && this.cachedServers && (now - this.lastUpdateTime) < this.CACHE_DURATION) {
                client.servers = this.cachedServers;
                this.renderServers(client);
                return true;
            }
            
            let servers = [];
            
            try {
                const res = await fetch(`${client.API_SERVER_URL}/api/servers`, {
                    headers: { 'Authorization': `Bearer ${client.token}` }
                });
                if (res.ok) {
                    const data = await res.json();
                    servers = Array.isArray(data.servers) ? data.servers : [];
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à
                    this.cachedServers = servers;
                    this.lastUpdateTime = now;
                }
            } catch (apiError) {
                servers = this.loadServersFromLocalStorage(client);
            }
            
            client.servers = servers;
            this.renderServers(client);
            return true;
        } catch (error) {
            return false;
        }
    }

    static renderServers(client) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;

        serversList.innerHTML = '';
        
        if (client.servers.length === 0) {
            serversList.innerHTML = '<div class="no-results">–ù–µ—Ç —Å–µ—Ä–≤–µ—Ä–æ–≤</div>';
            return;
        }
        
        client.servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            
            const isOwner = server.ownerId === client.userId;
            const isMember = server.members && server.members.includes(client.userId);
            
            serverElement.innerHTML = `üè† ${server.name} ${isOwner ? '<span class="owner-badge">(–í—ã)</span>' : ''}`;
            
            serverElement.addEventListener('click', () => {
                client.currentServerId = server.id;
                client.currentServer = server;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞
                localStorage.setItem('lastServerId', server.id);
                
                if (client.serverSearchInput) {
                    client.serverSearchInput.value = '';
                }
                
                setTimeout(() => {
                    RoomManager.loadRoomsForServer(client, server.id);
                    client.showPanel('rooms');
                }, 100);
            });
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'server-actions';
            
            if (isOwner) {
                // –ö–Ω–æ–ø–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞
                const inviteBtn = document.createElement('button');
                inviteBtn.className = 'server-action-btn';
                //inviteBtn.innerHTML = 'üîó';
                inviteBtn.title = '–°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ';
                inviteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.createServerInvite(client, server.id);
                });
                
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = 'üìã';
                shareBtn.title = '–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copyServerInviteLink(client, server.id);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '‚úï';
                deleteBtn.title = '–£–¥–∞–ª–∏—Ç—å';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteServer(client, server.id);
                });
                
                actionButtons.appendChild(inviteBtn);
                actionButtons.appendChild(shareBtn);
                actionButtons.appendChild(deleteBtn);
            } else if (isMember) {
                const leaveBtn = document.createElement('button');
                leaveBtn.className = 'server-action-btn leave-btn';
                leaveBtn.innerHTML = 'üö™';
                leaveBtn.title = '–ü–æ–∫–∏–Ω—É—Ç—å —Å–µ—Ä–≤–µ—Ä';
                leaveBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.leaveServer(client, server.id);
                });
                
                actionButtons.appendChild(leaveBtn);
            }
            
            serverElement.appendChild(actionButtons);
            serversList.appendChild(serverElement);
        });
    }

    static async createServerInvite(client, serverId) {
        try {
            const invite = await InviteManager.createServerInvite(serverId);
            
            if (invite) {
                const inviteLink = InviteManager.generateInviteLink(invite.code);
                
                UIManager.openModal('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ', `
                    <p>–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞ —Å–æ–∑–¥–∞–Ω–æ!</p>
                    <div class="invite-link-container">
                        <input type="text" id="inviteLinkInput" value="${inviteLink}" readonly>
                        <button onclick="navigator.clipboard.writeText('${inviteLink}').then(() => alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!'))">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                    </div>
                    <p>–°—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –¥–æ: ${new Date(invite.expiresAt).toLocaleDateString()}</p>
                `, () => {
                    UIManager.closeModal();
                });
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞:', error);
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ: ' + error.message);
        }
    }

    static async copyServerInviteLink(client, serverId) {
        try {
            const invites = await InviteManager.getServerInvites(serverId);
            
            if (invites && invites.length > 0) {
                const activeInvite = invites.find(invite => new Date(invite.expiresAt) > new Date());
                
                if (activeInvite) {
                    InviteManager.copyInviteLink(activeInvite.code);
                    return;
                }
            }
            
            const invite = await InviteManager.createServerInvite(serverId);
            if (invite) {
                InviteManager.copyInviteLink(invite.code);
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –∏–Ω–≤–∞–π—Ç–∞:', error);
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è');
        }
    }

    static async createServer(client) {
        const name = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞:');
        if (!name || name.length < 3) {
            alert('–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 —Å–∏–º–≤–æ–ª–æ–≤');
            return;
        }
        
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({ 
                    name: name.trim(), 
                    userId: client.userId, 
                    token: client.token 
                })
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                const errorMessage = errorData.error || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–µ—Ä–≤–µ—Ä';
                
                if (errorMessage.includes('—É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç')) {
                    alert(`–û—à–∏–±–∫–∞: ${errorMessage}. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.`);
                } else if (errorMessage.includes('–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç')) {
                    alert(`–û—à–∏–±–∫–∞: ${errorMessage}`);
                } else {
                    throw new Error(errorMessage);
                }
                return;
            }
            
            const data = await res.json();
            const serverData = data.server;
            
            client.servers.push(serverData);
            this.saveServersToLocalStorage(client);
            this.renderServers(client);
            client.currentServerId = serverData.id;
            client.currentServer = serverData;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞
            localStorage.setItem('lastServerId', serverData.id);
            
            await RoomManager.loadRoomsForServer(client, client.currentServerId);
            
        } catch (error) {
            alert('–û—à–∏–±–∫–∞: ' + error.message);
        }
    }

    static deleteServer(client, serverId) {
        if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä? –í—Å–µ –∫–æ–º–Ω–∞—Ç—ã –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.')) return;
        
        const serverIndex = client.servers.findIndex(s => s.id === serverId);
        if (serverIndex !== -1) {
            const serverName = client.servers[serverIndex].name;
            client.servers = client.servers.filter(server => server.id !== serverId);
            this.saveServersToLocalStorage(client);
            this.renderServers(client);
            
            if (client.currentServerId === serverId) {
                client.currentServerId = null;
                client.currentServer = null;
                
                // –û—á–∏—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                localStorage.removeItem('lastServerId');
                localStorage.removeItem('lastRoomId');
            }
            
            UIManager.addMessage('System', `‚úÖ –°–µ—Ä–≤–µ—Ä "${serverName}" —É–¥–∞–ª–µ–Ω`);
        }
    }

    static async searchServers(client, query) {
        try {
            if (!query || query.length < 2) {
                this.renderServers(client);
                return;
            }

            const res = await fetch(`${client.API_SERVER_URL}/api/servers/search?q=${encodeURIComponent(query)}`, {
                headers: { 
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || '–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞');
            }
            
            const data = await res.json();
            this.renderSearchResults(client, data.servers);
        } catch (error) {
            UIManager.showError('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ' + error.message);
        }
    }

    static renderSearchResults(client, servers) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;

        serversList.innerHTML = '';
        
        if (servers.length === 0) {
            serversList.innerHTML = '<div class="no-results">–°–µ—Ä–≤–µ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            return;
        }
        
        servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            
            const isOwner = server.ownerId === client.userId;
            const isMember = client.servers.some(s => s.id === server.id);
            
            serverElement.innerHTML = `üè† ${server.name} ${isOwner ? '<span class="owner-badge">(–í—ã)</span>' : ''} ${!isMember ? '<span class="not-member-badge">(–ù–µ —É—á–∞—Å—Ç–Ω–∏–∫)</span>' : ''}`;
            
            if (isMember) {
                serverElement.addEventListener('click', () => {
                    client.currentServerId = server.id;
                    client.currentServer = server;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞
                    localStorage.setItem('lastServerId', server.id);
                    
                    if (client.serverSearchInput) {
                        client.serverSearchInput.value = '';
                    }
                    
                    setTimeout(() => {
                        RoomManager.loadRoomsForServer(client, server.id);
                        client.showPanel('rooms');
                    }, 100);
                });
            } else {
                serverElement.style.opacity = '0.7';
                serverElement.style.cursor = 'default';
                
                const joinBtn = document.createElement('button');
                joinBtn.className = 'server-action-btn join-btn';
                joinBtn.innerHTML = '‚ûï';
                joinBtn.title = '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è';
                joinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.joinServer(client, server.id);
                });
                
                serverElement.appendChild(joinBtn);
            }
            
            if (isOwner) {
                const actionButtons = document.createElement('div');
                actionButtons.className = 'server-actions';
                
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = 'üîó';
                shareBtn.title = '–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copyServerInviteLink(client, server.id);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '‚úï';
                deleteBtn.title = '–£–¥–∞–ª–∏—Ç—å';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteServer(client, server.id);
                });
                
                actionButtons.appendChild(shareBtn);
                actionButtons.appendChild(deleteBtn);
                serverElement.appendChild(actionButtons);
            }
            
            serversList.appendChild(serverElement);
        });
    }

    static async joinServer(client, serverId) {
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({ userId: client.userId, token: client.token })
            });

            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è');
            }

            const data = await res.json();
            const server = data.server;

            const exists = client.servers.some(s => s.id === server.id);
            if (!exists) {
                client.servers.push(server);
                this.saveServersToLocalStorage(client);
            }

            if (client.serverSearchInput) {
                client.serverSearchInput.value = '';
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞
            localStorage.setItem('lastServerId', server.id);
            
            this.renderServers(client);
            client.showPanel('servers');
            
            UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ "${server.name}"`);

        } catch (error) {
            UIManager.showError(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è: ${error.message}`);
        }
    }

    static async leaveServer(client, serverId) {
        if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∫–∏–Ω—É—Ç—å —ç—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä?')) return;
        
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/leave`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∏–Ω—É—Ç—å —Å–µ—Ä–≤–µ—Ä');
            }
            
            client.servers = client.servers.filter(server => server.id !== serverId);
            this.saveServersToLocalStorage(client);
            
            // –û—á–∏—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –µ—Å–ª–∏ –≤—ã—Ö–æ–¥–∏–º —Å —Ç–µ–∫—É—â–µ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞
            if (client.currentServerId === serverId) {
                client.currentServerId = null;
                client.currentServer = null;
                client.currentRoom = null;
                
                localStorage.removeItem('lastServerId');
                localStorage.removeItem('lastRoomId');
            }
            
            this.renderServers(client);
            
            UIManager.addMessage('System', `‚úÖ –í—ã –ø–æ–∫–∏–Ω—É–ª–∏ —Å–µ—Ä–≤–µ—Ä`);
            
        } catch (error) {
            UIManager.showError('–û—à–∏–±–∫–∞: ' + error.message);
        }
    }

    static clearSearchAndShowAllServers(client) {
        if (client.serverSearchInput) {
            client.serverSearchInput.value = '';
        }
        
        this.renderServers(client);
    }
}

export default ServerManager;


TextChatManager.js:
import UIManager from './UIManager.js';

class TextChatManager {
    static setupSocketHandlers(client) {
        if (!client.socket) return;

        client.socket.on('new-message', (message) => {
            console.log('New message received:', message);
            if (message.roomId === client.currentRoom) {
                // ‚úÖ –ü–µ—Ä–µ–¥–∞—ë–º messageId –∏ readBy
                UIManager.addMessage(
                    message.username,
                    message.text,
                    message.timestamp,
                    message.type,
                    message.imageUrl,
                    message.id,               // messageId
                    message.readBy || []      // readBy
                );
            }
        });

        client.socket.on('text-message-history', (data) => {
            console.log('Message history received:', data);
            if (data.roomId === client.currentRoom && data.messages) {
                UIManager.clearMessages();
                data.messages.forEach(msg => {
                    // ‚úÖ –ü–µ—Ä–µ–¥–∞—ë–º messageId –∏ readBy
                    UIManager.addMessage(
                        msg.username,
                        msg.text,
                        msg.timestamp,
                        msg.type,
                        msg.imageUrl,
                        msg.id,                   // messageId
                        msg.readBy || []          // readBy
                    );
                });
            }
        });

        client.socket.on('messages-read', (data) => {
            if (data.messageIds && Array.isArray(data.messageIds)) {
                data.messageIds.forEach(id => {
                    UIManager.updateMessageReadStatus(id, data.readerId, data.readerName);
                });
            }
        });

        client.socket.on('connect', () => {
            console.log('Socket connected');
            UIManager.updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ', 'connected');
            if (client.currentRoom) {
                this.joinTextRoom(client, client.currentRoom);
            }
        });

        client.socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            UIManager.updateStatus('–û—Ç–∫–ª—é—á–µ–Ω–æ', 'disconnected');
        });
    }

    static joinTextRoom(client, roomId) {
        if (client.socket) {
            client.socket.emit('join-text-room', { roomId });
        }
    }

    static leaveTextRoom(client, roomId) {
        if (client.socket) {
            client.socket.emit('leave-text-room', { roomId });
        }
    }

    static async loadMoreMessages(client, roomId, beforeMessageId) {
        return this.loadMessages(client, roomId, 50, beforeMessageId);
    }

    static async loadMessages(client, roomId, limit = 100, before = null) {
        try {
            const params = new URLSearchParams();
            params.append('limit', limit);
            if (before) params.append('before', before);
            const response = await fetch(`${client.API_SERVER_URL}/api/chat/rooms/${roomId}/messages?${params}`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            if (response.ok) {
                const data = await response.json();
                console.log('[TextChatManager.loadMessages] Raw response from server:', data);
                if (data.messages && Array.isArray(data.messages)) {
                    if (!before) {
                        UIManager.clearMessages();
                    }
                    data.messages.forEach(message => {
                        console.log('[TextChatManager] Processing message for UI:', {
                            id: message.id,
                            type: message.type,
                            imageUrl: message.imageUrl,
                            username: message.username
                        });
                        UIManager.addMessage(
                            message.username,
                            message.text,
                            message.timestamp,
                            message.type,
                            message.imageUrl,
                            message.id,
                            message.readBy || []
                        );
                    });
                }
            }
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    static async uploadImage(client, roomId, file) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            throw new Error('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ JPEG, PNG –∏ WebP');
        }
        if (file.size > 5 * 1024 * 1024) {
            throw new Error('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 5 –ú–ë)');
        }

        const formData = new FormData();
        formData.append('image', file);

        const response = await fetch(`${client.API_SERVER_URL}/api/messages/upload-image/${roomId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${client.token}`
            },
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
        }

        const result = await response.json();
        return result.imageUrl;
    }

    static async markMessagesAsRead(client, messageIds) {
        if (!client.currentRoom || !Array.isArray(messageIds) || messageIds.length === 0) return;
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/messages/${client.currentRoom}/read`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({ messageIds })
            });
            if (!response.ok) {
                console.warn('Failed to mark messages as read');
            }
        } catch (error) {
            console.error('Error marking messages as read:', error);
        }
    }

    static async sendMessage(client, content, type = 'text') {
        if (!client.currentRoom) return;

        let payload;
        if (type === 'text') {
            if (!content?.trim()) return;
            payload = {
                roomId: client.currentRoom,
                type: 'text',
                text: content.trim()
            };
        } else if (type === 'image') {
            if (!content) throw new Error('imageUrl required for image message');
            payload = {
                roomId: client.currentRoom,
                type: 'image',
                imageUrl: content
            };
        } else {
            throw new Error('Unsupported message type');
        }

        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è');
            }

            const data = await response.json();
            return data.message;
        } catch (error) {
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ');
            throw error;
        }
    }
}

export default TextChatManager;


UIManager.js:
import MembersManager from './MembersManager.js';

class UIManager {
    static client = null;

    static setClient(client) {
        this.client = client;
    }

    static updateStatus(text, status) {
        const statusText = document.querySelector('.status-text');
        const statusIndicator = document.querySelector('.status-indicator');
        if (statusText) {
            statusText.textContent = text;
        }
        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            if (status === 'connecting') {
                statusIndicator.classList.add('connecting');
            } else if (status === 'disconnected') {
                statusIndicator.classList.add('disconnected');
            } else if (status === 'connected') {
                statusIndicator.classList.add('connected');
            }
        }
    }

    static updatePTTButton(isActive) {
        const pttButton = document.querySelector('.ptt-setup-btn');
        if (pttButton) {
            if (isActive) {
                pttButton.classList.add('active');
            } else {
                pttButton.classList.remove('active');
            }
        }
    }

    static openCreateRoomModal(client, onSubmit) {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.style.display = 'flex';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã</h2>
                <input type="text" id="roomNameInput" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã" required>
                <div class="modal-buttons">
                    <button id="confirmCreateRoom">–°–æ–∑–¥–∞—Ç—å</button>
                    <button id="cancelCreateRoom">–û—Ç–º–µ–Ω–∞</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        const handleConfirm = () => {
            const name = document.getElementById('roomNameInput').value.trim();
            if (name.length < 3) {
                alert('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 3 —Å–∏–º–≤–æ–ª–æ–≤');
                return;
            }
            modalOverlay.remove();
            onSubmit(name);
        };
        const handleCancel = () => {
            modalOverlay.remove();
        };
        modalOverlay.querySelector('#confirmCreateRoom').addEventListener('click', handleConfirm);
        modalOverlay.querySelector('#cancelCreateRoom').addEventListener('click', handleCancel);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                handleCancel();
            }
        });
    }

    static updateRoomTitle(title) {
        const titleElement = document.querySelector('.current-room-title');
        if (titleElement) {
            titleElement.textContent = title;
        }
    }

    static addMessage(user, text, timestamp = null, type = 'text', imageUrl = null, messageId = null, readBy = [], userId = null) {
        const messagesContainer = document.querySelector('.messages-container');
        if (!messagesContainer) return;
        const safeUser = user || 'Unknown';
        const safeText = text || '';
        
        // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ø—Ä–æ–≤–µ—Ä—è–µ–º userId —Å–æ–æ–±—â–µ–Ω–∏—è —Å userId –∫–ª–∏–µ–Ω—Ç–∞
        const isOwn = this.client && userId && this.client.userId && userId.toString() === this.client.userId.toString();

        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        if (messageId) messageElement.dataset.messageId = messageId;
        if (readBy?.length) messageElement.dataset.readBy = JSON.stringify(readBy);

        const time = timestamp
            ? new Date(timestamp).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })
            : new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });

        let finalImageUrl = imageUrl;
        if (type === 'image' && imageUrl?.startsWith('/')) {
            if (this.client?.API_SERVER_URL) {
                finalImageUrl = this.client.API_SERVER_URL + imageUrl;
            }
        }

        // –ê–≤–∞—Ç–∞—Ä —Ç–æ–ª—å–∫–æ —É —á—É–∂–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        const avatarHtml = isOwn ? '' : `<div class="message-avatar">${safeUser.charAt(0).toUpperCase()}</div>`;

        if (type === 'image') {
            messageElement.innerHTML = `
                ${avatarHtml}
                <div class="message-content${isOwn ? ' own' : ''}">
                    <div class="message-header">
                        <span class="message-username">${this.escapeHtml(safeUser)}</span>
                        <span class="message-time">${time}</span>
                    </div>
                    <div class="message-text"><img src="${this.escapeHtml(finalImageUrl)}" alt="–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ" class="message-image"></div>
                </div>
            `;
        } else {
            messageElement.innerHTML = `
                ${avatarHtml}
                <div class="message-content${isOwn ? ' own' : ''}">
                    <div class="message-header">
                        <span class="message-username">${this.escapeHtml(safeUser)}</span>
                        <span class="message-time">${time}</span>
                    </div>
                    <div class="message-text">${this.escapeHtml(safeText)}</div>
                </div>
            `;
        }

        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        setTimeout(() => messageElement.classList.add('appeared'), 10);
    }

    static updateMicButton(status) {
        const micButton = document.querySelector('.mic-button');
        const micToggleBtn = document.querySelector('.mic-toggle-btn');
        const states = {
            'disconnected': {class: 'disconnected', text: 'üé§', title: '–ù–µ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –≥–æ–ª–æ—Å–æ–≤–æ–º—É –∫–∞–Ω–∞–ª—É'},
            'connecting': {class: 'connecting', text: 'üé§', title: '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...'},
            'connected': {class: 'connected', text: 'üé§', title: '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω (–Ω–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å)'},
            'active': {class: 'active', text: 'üî¥', title: '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω (–Ω–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –≤—ã–∫–ª—é—á–∏—Ç—å)'},
            'error': {class: 'error', text: 'üé§', title: '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É'}
        };
        const state = states[status] || states.disconnected;
        if (micButton) {
            micButton.className = 'mic-button ' + state.class;
            micButton.textContent = state.text;
            micButton.title = state.title;
        }
        if (micToggleBtn) {
            micToggleBtn.className = 'mic-toggle-btn ' + state.class;
            micToggleBtn.textContent = state.text;
            micToggleBtn.title = state.title;
        }
    }

    static updateAudioStatus(activeConsumers) {
        const statusElement = document.querySelector('.audio-status');
        if (!statusElement) return;
        if (activeConsumers > 0) {
            statusElement.textContent = `–ê–∫—Ç–∏–≤–Ω—ã—Ö –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫–æ–≤: ${activeConsumers}`;
            statusElement.style.color = 'var(--success)';
        } else {
            statusElement.textContent = '–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫–æ–≤';
            statusElement.style.color = 'var(--text-muted)';
        }
    }

    static renderServers(client) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;
        serversList.innerHTML = '';
        client.servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            const isOwner = server.ownerId === client.userId;
            serverElement.innerHTML = `üè† ${server.name} ${isOwner ? '<span class="owner-badge">(–í—ã)</span>' : ''}`;
            serverElement.addEventListener('click', () => {
                client.currentServerId = server.id;
                client.currentServer = server;
                import('./RoomManager.js').then(module => {
                    module.default.loadRoomsForServer(client, server.id);
                });
                client.showPanel('rooms');
            });
            if (isOwner) {
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = 'üîó';
                shareBtn.title = '–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const inviteLink = `${window.location.origin}${window.location.pathname}?invite=${server.id}`;
                    navigator.clipboard.writeText(inviteLink)
                        .then(() => alert(`–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞: ${inviteLink}`))
                        .catch(() => {});
                });
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '‚úï';
                deleteBtn.title = '–£–¥–∞–ª–∏—Ç—å';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    import('./ServerManager.js').then(module => {
                        module.default.deleteServer(client, server.id);
                    });
                });
                serverElement.appendChild(shareBtn);
                serverElement.appendChild(deleteBtn);
            }
            serversList.appendChild(serverElement);
        });
    }

    static renderRooms(client, rooms) {
        const roomsList = document.querySelector('.rooms-list');
        if (!roomsList) return;
        roomsList.innerHTML = '';
        rooms.forEach(room => {
            const roomElement = document.createElement('div');
            roomElement.className = 'room-item';
            roomElement.dataset.room = room.id;
            const isOwner = room.ownerId === client.userId;
            roomElement.innerHTML = `üîä ${room.name} ${isOwner ? '<span class="owner-badge">(–í—ã)</span>' : ''}`;
            roomElement.addEventListener('click', () => {
                client.currentRoom = room.id;
                client.joinRoom(room.id);
            });
            roomsList.appendChild(roomElement);
        });
    }

    static updateMembersList(members) {
        const membersList = document.querySelector('.members-list');
        if (!membersList) return;
        membersList.innerHTML = '';
        if (this.client && this.client.username) {
            const selfElement = document.createElement('div');
            selfElement.className = 'member-item';
            const selfUsername = this.client.username || '–í—ã';
            selfElement.innerHTML = `
                <div class="member-avatar">${selfUsername.charAt(0).toUpperCase()}</div>
                <div class="member-name">${selfUsername}</div>
                <div class="member-status">
                    <div class="status-indicator online" title="Online"></div>
                    <div class="mic-indicator ${this.client.isMicActive ? 'active' : ''}" title="${this.client.isMicActive ? 'Microphone active' : 'Microphone muted'}"></div>
                </div>
            `;
            membersList.appendChild(selfElement);
        }
        members.forEach(user => {
            if (!user || !user.userId) {
                console.warn('[UIManager] –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ (–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç userId):', user);
                return;
            }
            if (this.client && user.userId === this.client.userId) {
                return;
            }
            const memberElement = document.createElement('div');
            memberElement.className = 'member-item';
            memberElement.dataset.userId = user.userId;
            const isOnline = user.isOnline === true;
            const statusClass = isOnline ? 'online' : 'offline';
            const statusTitle = isOnline ? 'Online' : 'Offline';
            memberElement.innerHTML = `
                <div class="member-avatar">${user.username.charAt(0).toUpperCase()}</div>
                <div class="member-name">${user.username}</div>
                <div class="member-status">
                    <div class="status-indicator ${statusClass}" title="${statusTitle}"></div>
                    <div class="mic-indicator ${isOnline && user.isMicActive ? 'active' : ''}" title="${user.isMicActive ? 'Microphone active' : 'Microphone muted'}"></div>
                </div>
            `;
            membersList.appendChild(memberElement);
        });
    }

    static updateMemberMicState(userId, isActive) {
        const memberElement = document.querySelector(`.member-item[data-user-id="${userId}"]`);
        if (memberElement) {
            const micIndicator = memberElement.querySelector('.mic-indicator');
            if (micIndicator) {
                const member = MembersManager.getMember(userId);
                if (member && member.isOnline) {
                    micIndicator.className = isActive ? 'mic-indicator active' : 'mic-indicator';
                    micIndicator.title = isActive ? 'Microphone active' : 'Microphone muted';
                } else {
                    micIndicator.className = 'mic-indicator';
                    micIndicator.title = 'Microphone muted';
                }
            }
        }
    }

    static openModal(title, content, onSubmit) {
        const modalOverlay = document.querySelector('.modal-overlay');
        const modalContent = document.querySelector('.modal-content');
        if (!modalOverlay || !modalContent) return;
        modalContent.innerHTML = `
            <h2>${title}</h2>
            ${content}
            <button class="modal-submit">OK</button>
        `;
        modalOverlay.classList.remove('hidden');
        const submitButton = modalContent.querySelector('.modal-submit');
        if (submitButton && onSubmit) {
            submitButton.addEventListener('click', onSubmit);
        }
    }

    static closeModal() {
        const modalOverlay = document.querySelector('.modal-overlay');
        if (modalOverlay) modalOverlay.classList.add('hidden');
    }

    static showError(message) {
        const errorElement = document.createElement('div');
        errorElement.className = 'error-message';
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ed4245;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            max-width: 300px;
        `;
        document.body.appendChild(errorElement);
        setTimeout(() => {
            if (document.body.contains(errorElement)) {
                document.body.removeChild(errorElement);
            }
        }, 5000);
    }

    static escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    static openSettings(client) {
        const modalContent = `
            <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            <div class="setting-item">
                <label>–ë–∏—Ç—Ä–µ–π—Ç: <span id="bitrateValue">${client.bitrate / 1000}</span> kbps</label>
                <input type="range" id="bitrateSlider" min="16" max="64" value="${client.bitrate / 1000}" step="1">
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="dtxCheckbox" ${client.dtxEnabled ? 'checked' : ''}>
                    DTX (Discontinuous Transmission)
                </label>
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="fecCheckbox" ${client.fecEnabled ? 'checked' : ''}>
                    FEC (Forward Error Correction)
                </label>
            </div>
            <button class="apply-settings-btn">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        `;
        this.openModal('–ù–∞—Å—Ç—Ä–æ–π–∫–∏', modalContent, () => {
            client.bitrate = document.getElementById('bitrateSlider').value * 1000;
            client.dtxEnabled = document.getElementById('dtxCheckbox').checked;
            client.fecEnabled = document.getElementById('fecCheckbox').checked;
            this.closeModal();
        });
        const bitrateSlider = document.getElementById('bitrateSlider');
        const bitrateValue = document.getElementById('bitrateValue');
        if (bitrateSlider && bitrateValue) {
            bitrateSlider.addEventListener('input', () => {
                bitrateValue.textContent = bitrateSlider.value;
            });
        }
    }

    static onRoomJoined(client, roomName) {
        this.updateRoomTitle(roomName);
        this.updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ', 'connected');
    }

    static openPanel(client, panel) {
        if (!panel) return;
        panel.style.display = 'flex';
        setTimeout(() => {
            panel.style.opacity = '1';
            panel.style.transform = 'translateX(0)';
        }, 10);
    }

    static closePanel(client, panel) {
        if (!panel) return;
        panel.style.opacity = '0';
        panel.style.transform = 'translateX(-100%)';
        setTimeout(() => {
            panel.style.display = 'none';
        }, 300);
    }

    static toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        sidebar.classList.toggle('open');
    }

    static toggleMembersPanel(client) {
        const membersPanel = document.querySelector('.members-panel');
        membersPanel.classList.toggle('open');
    }

    static applySettings(client) {
        client.bitrate = document.getElementById('bitrateSlider').value * 1000;
        client.dtxEnabled = document.getElementById('dtxCheckbox').checked;
        client.fecEnabled = document.getElementById('fecCheckbox').checked;
        this.closeModal();
    }

    static updateRoomUI(client) {
        const messagesContainer = document.querySelector('.messages-container');
        if (messagesContainer) {
            messagesContainer.innerHTML = '';
        }
        let roomTitle = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–Ω–∞—Ç—É';
        if (client.currentRoom) {
            const currentRoomData = client.rooms.find(room => room.id === client.currentRoom);
            if (currentRoomData) {
                roomTitle = `–ö–æ–º–Ω–∞—Ç–∞: ${currentRoomData.name}`;
            } else {
                roomTitle = `–ö–æ–º–Ω–∞—Ç–∞: ${client.currentRoom}`;
            }
        }
        this.updateRoomTitle(roomTitle);
        this.updateMicButton(client.isConnected ? (client.isMicActive ? 'active' : 'connected') : 'disconnected');
    }

    static clearMessages() {
        const messagesContainer = document.querySelector('.messages-container');
        if (messagesContainer) {
            messagesContainer.innerHTML = '';
        }
    }
}

export default UIManager;

UserPresenceManager.js:
import UIManager from './UIManager.js';

class UserPresenceManager {
    static PRESENCE_UPDATE_INTERVAL = 30000; // 30 —Å–µ–∫—É–Ω–¥
    static INACTIVITY_TIMEOUT = 300000; // 5 –º–∏–Ω—É—Ç

    static init(client) {
        this.client = client;
        this.lastActivityTime = Date.now();
        this.setupActivityTracking();
        this.startPresenceUpdates();
    }

    static setupActivityTracking() {
        // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const activityEvents = [
            'mousedown', 'mousemove', 'keypress', 
            'scroll', 'touchstart', 'click',
            'message', 'mic-state-change'
        ];

        activityEvents.forEach(event => {
            document.addEventListener(event, () => {
                this.updateLastActivity();
            }, { passive: true });
        });

        // –¢–∞–∫–∂–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ —á–∞—Ç–µ
        const originalAddMessage = UIManager.addMessage;
        UIManager.addMessage = function(...args) {
            originalAddMessage.apply(this, args);
            UserPresenceManager.updateLastActivity();
        };
    }

    static updateLastActivity() {
        this.lastActivityTime = Date.now();
        
        // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–∞–ª –∞–∫—Ç–∏–≤–Ω—ã–º –ø–æ—Å–ª–µ –ø–µ—Ä–∏–æ–¥–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        if (!this.isUserActive && this.client.userId) {
            this.setUserActive(true);
        }
    }

    static async setUserActive(isActive) {
        if (!this.client.userId || !this.client.token) return;

        this.isUserActive = isActive;

        try {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/update`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    isOnline: isActive,
                    currentRoom: this.client.currentRoom,
                    lastActivity: new Date().toISOString()
                })
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞');
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è:', error);
        }
    }

    static startPresenceUpdates() {
        // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è
        this.presenceInterval = setInterval(() => {
            this.checkActivity();
            this.updatePresence();
        }, this.PRESENCE_UPDATE_INTERVAL);

        // –¢–∞–∫–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–º–Ω–∞—Ç—ã
        const originalJoinRoom = this.client.joinRoom;
        this.client.joinRoom = async (...args) => {
            const result = await originalJoinRoom.apply(this.client, args);
            if (result) {
                this.updatePresence();
            }
            return result;
        };

        const originalLeaveRoom = this.client.leaveRoom;
        this.client.leaveRoom = async (...args) => {
            const result = await originalLeaveRoom.apply(this.client, args);
            if (result) {
                this.updatePresence();
            }
            return result;
        };
    }

static checkActivity() {
    const currentTime = Date.now();
    const inactiveTime = currentTime - this.lastActivityTime;

    // –û—Å–Ω–æ–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–Ω–ª–∞–π–Ω, –µ—Å–ª–∏ –æ–Ω –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∫–æ–º–Ω–∞—Ç–µ.
    // –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –º—ã—à–∏/–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –≤–ª–∏—è–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ "—Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏", –Ω–æ –Ω–µ –Ω–∞ "–æ–Ω–ª–∞–π–Ω/–æ—Ñ—Ñ–ª–∞–π–Ω".
    const shouldBeOnline = this.client.currentRoom !== null;

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω/–æ—Ñ—Ñ–ª–∞–π–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è –≤ –∫–æ–º–Ω–∞—Ç–µ
    if (shouldBeOnline !== this.isUserActive) {
        this.setUserActive(shouldBeOnline);
    }

    // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–±—ã—Ç–∏–µ –æ "–Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏" (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∑–Ω–∞—á–∫–∞ "–Ω–µ–∞–∫—Ç–∏–≤–µ–Ω"),
    // –Ω–æ —ç—Ç–æ –Ω–µ –¥–æ–ª–∂–Ω–æ –≤–ª–∏—è—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–∞—Ç—É—Å "–æ–Ω–ª–∞–π–Ω".
    // if (inactiveTime > this.INACTIVITY_TIMEOUT) {
    //     // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω"
    // } else {
    //     // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–∫—Ç–∏–≤–µ–Ω"
    // }
}
    static async updatePresence() {
        if (!this.client.userId || !this.client.token) return;

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/update`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    currentRoom: this.client.currentRoom,
                    isMicActive: this.client.isMicActive,
                    lastActivity: new Date().toISOString()
                })
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è');
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è:', error);
        }
    }

    static async getOnlineUsers(roomId = null) {
        if (!this.client.token) return [];

        try {
            let url = `${this.client.API_SERVER_URL}/api/presence/online-users`;
            if (roomId) {
                url += `?roomId=${roomId}`;
            }

            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π');
            }

            const data = await response.json();
            return data.users || [];
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
            return [];
        }
    }

    static async getUserPresence(userId) {
        if (!this.client.token) return { isOnline: false, lastSeen: null };

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/user/${userId}`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
            return { isOnline: false, lastSeen: null };
        }
    }

    static async subscribeToPresenceUpdates(roomId) {
        if (!this.client.socket || !roomId) return;

        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç
        this.client.socket.emit('subscribe-presence', { roomId });

        this.client.socket.on('presence-update', (data) => {
            this.handlePresenceUpdate(data);
        });

        this.client.socket.on('user-joined', (data) => {
            this.handleUserJoined(data);
        });

        this.client.socket.on('user-left', (data) => {
            this.handleUserLeft(data);
        });
    }

    static handlePresenceUpdate(data) {
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const { userId, isOnline, isMicActive, lastSeen } = data;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º UI
        UIManager.updateUserPresence(userId, {
            isOnline,
            isMicActive,
            lastSeen: lastSeen ? new Date(lastSeen) : null
        });
    }

    static handleUserJoined(data) {
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const { userId, username, isMicActive } = data;
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ UI
        UIManager.addUser({
            userId,
            username,
            isMicActive: isMicActive || false,
            isOnline: true
        });

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${username} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è`, new Date().toISOString());
    }

    static handleUserLeft(data) {
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—ã—Ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const { userId, username } = data;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ UI
        UIManager.updateUserPresence(userId, {
            isOnline: false,
            isMicActive: false,
            lastSeen: new Date().toISOString()
        });

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${username} –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç`, new Date().toISOString());
    }

    static async updateMicState(isActive) {
        if (!this.client.userId || !this.client.token) return;

        this.client.isMicActive = isActive;

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/mic-state`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    isActive: isActive,
                    roomId: this.client.currentRoom
                })
            });

            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞');
            }

            // –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            if (this.client.socket && this.client.currentRoom) {
                this.client.socket.emit('mic-state-change', {
                    isActive: isActive,
                    roomId: this.client.currentRoom
                });
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞:', error);
        }
    }

    static cleanup() {
        if (this.presenceInterval) {
            clearInterval(this.presenceInterval);
        }

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ñ—Ñ–ª–∞–π–Ω –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
        if (this.client.userId) {
            this.setUserActive(false);
        }
    }
}

export default UserPresenceManager;


Utils.js:
class Utils {
    static generateClientID() {
        return 'client_' + Math.random().toString(36).substr(2, 9);
    }

    static escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    static debounce(func, wait, immediate = false) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                if (!immediate) func(...args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func(...args);
        };
    }

    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    static formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('ru-RU', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    static generateRandomString(length = 8) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    static isValidEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }

    static copyToClipboard(text) {
        return new Promise((resolve, reject) => {
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(resolve)
                    .catch(reject);
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    resolve();
                } catch (err) {
                    reject(err);
                }
                document.body.removeChild(textArea);
            }
        });
    }

    static formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    static isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    static getOS() {
        const userAgent = navigator.userAgent;
        if (/Windows/.test(userAgent)) return 'Windows';
        if (/Mac/.test(userAgent)) return 'MacOS';
        if (/Linux/.test(userAgent)) return 'Linux';
        if (/Android/.test(userAgent)) return 'Android';
        if (/iOS|iPhone|iPad|iPod/.test(userAgent)) return 'iOS';
        return 'Unknown';
    }

    static getBrowser() {
        const userAgent = navigator.userAgent;
        if (/Edg/.test(userAgent)) return 'Edge';
        if (/Chrome/.test(userAgent)) return 'Chrome';
        if (/Firefox/.test(userAgent)) return 'Firefox';
        if (/Safari/.test(userAgent)) return 'Safari';
        if (/Opera|OPR/.test(userAgent)) return 'Opera';
        return 'Unknown';
    }

    static sanitizeInput(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    }

    static parseJWT(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        } catch (e) {
            return null;
        }
    }

    static isJWTExpired(token) {
        const payload = this.parseJWT(token);
        if (!payload || !payload.exp) return true;
        return Date.now() >= payload.exp * 1000;
    }

    static arrayToObject(array, keyField, valueField = null) {
        return array.reduce((obj, item) => {
            obj[item[keyField]] = valueField ? item[valueField] : item;
            return obj;
        }, {});
    }

    static deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    static mergeObjects(...objects) {
        return objects.reduce((merged, obj) => {
            return { ...merged, ...obj };
        }, {});
    }

    static capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    static truncateString(str, maxLength, suffix = '...') {
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength) + suffix;
    }

    static isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }

    static scrollToElement(element, behavior = 'smooth') {
        element.scrollIntoView({ behavior, block: 'nearest' });
    }

    static formatNumber(number, decimals = 0) {
        return new Intl.NumberFormat('ru-RU', {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        }).format(number);
    }

    static formatCurrency(amount, currency = 'RUB') {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: currency
        }).format(amount);
    }

    static getQueryParams() {
        const params = {};
        const queryString = window.location.search.substring(1);
        const pairs = queryString.split('&');
        
        for (const pair of pairs) {
            const [key, value] = pair.split('=');
            if (key) {
                params[decodeURIComponent(key)] = decodeURIComponent(value || '');
            }
        }
        
        return params;
    }

    static setQueryParams(params) {
        const searchParams = new URLSearchParams();
        
        for (const key in params) {
            if (params[key] !== undefined && params[key] !== null) {
                searchParams.set(key, params[key]);
            }
        }
        
        const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
        window.history.replaceState({}, '', newUrl);
    }
}

export default Utils;


VoiceChatClient.js:
import MediaManager from './MediaManager.js';
import RoomManager from './RoomManager.js';
import ServerManager from './ServerManager.js';
import UIManager from './UIManager.js';
import Utils from './Utils.js';
import TextChatManager from './TextChatManager.js';
import UserPresenceManager from './UserPresenceManager.js';
import InviteManager from './InviteManager.js';
import MembersManager from './MembersManager.js';
import AuthManager from './AuthManager.js';

class VoiceChatClient {
    constructor() {
        this.API_SERVER_URL = 'https://ns.fiber-gate.ru';
        this.CHAT_API_URL = `${this.API_SERVER_URL}/api/join`;
        this.clientID = Utils.generateClientID();
        this.device = null;
        this.sendTransport = null;
        this.recvTransport = null;
        this.audioProducer = null;
        this.consumerState = new Map();
        this.stream = null;
        this.isMicActive = false;
        this.currentRoom = null;
        this.currentServerId = null;
        this.currentServer = null;
        this.servers = [];
        this.rooms = [];
        this.keepAliveInterval = null;
        this.bitrate = 32000;
        this.dtxEnabled = true;
        this.fecEnabled = true;
        this.isConnected = false;
        this.mediaData = null;
        this.userId = null;
        this.token = null;
        this.username = null;
        this.syncInterval = null;
        this.activePanel = 'servers';
        this.inviteServerId = null;
        this.isCreatingRoom = false;
        this.socket = null;
        this.sseConnection = null;
        this.wasMicActiveBeforeReconnect = false;
        this.isReconnecting = false;
        this.pendingInviteCode = null;
        this.useHttpPolling = false;
        this.elements = {};
        this.debouncedSync = Utils.debounce(() => this.startConsuming(), 1000);
        this.pttHotkey = null;
        this.pttTimeoutId = null;
        this.isPTTActive = false;
        this.isMicInitializing = false;
        this.init();
    }

    playSound(soundName) {
        if (typeof Audio === 'undefined') return;
        const audio = new Audio(`./sounds/${soundName}.mp3`);
        audio.volume = 0.6;
        // –ò–≥—Ä–∞–µ–º –∑–≤—É–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞—É–¥–∏–æ–∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω
        audio.play().catch(err => {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "play() failed because user didn't interact")
            console.debug(`[Sound] Could not play ${soundName}:`, err.message);
        });
    }

    async init() {
        console.log('VoiceChatClient initializing...');
        this.initElements();
        this.initEventListeners();
        UIManager.setClient(this);
        UserPresenceManager.init(this);
        InviteManager.init(this);
        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ PTT
        if (window.electronAPI?.onPTTPressed) {
            window.electronAPI.onPTTPressed(() => {
                this.handlePTTPressed();
            });
        }
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π PTT-—Ö–æ—Ç–∫–µ–π
        if (window.electronAPI?.getPTTHotkey) {
            try {
                this.pttHotkey = await window.electronAPI.getPTTHotkey();
                if (this.pttHotkey) {
                    console.log('Loaded PTT hotkey:', this.pttHotkey);
                }
            } catch (error) {
                console.error('Error loading PTT hotkey:', error);
            }
        }
        await this.initAutoConnect();
        this.initMessageReadObserver();
    }

    initElements() {
        console.log('Initializing UI elements...');
        this.elements.micButton = document.querySelector('.mic-button');
        this.elements.micToggleBtn = document.querySelector('.mic-toggle-btn');
        this.elements.messageInput = document.querySelector('.message-input');
        this.elements.sendButton = document.querySelector('.send-btn');
        this.elements.currentRoomTitle = document.querySelector('.current-room-title');
        this.elements.toggleSidebarBtn = document.querySelector('.toggle-sidebar-btn');
        this.elements.toggleMembersBtn = document.querySelector('.toggle-members-btn');
        this.elements.settingsBtn = document.querySelector('.settings-btn');
        this.elements.closePanelBtn = document.querySelector('.close-panel-btn');
        this.elements.closeSidebarBtn = document.querySelector('.close-sidebar-btn');
        this.elements.createServerBtn = document.querySelector('.create-server-btn');
        this.elements.createRoomBtn = document.querySelector('.create-room-btn');
        this.elements.serversToggleBtn = document.querySelector('#serversToggle');
        this.elements.roomsToggleBtn = document.querySelector('#roomsToggle');
        this.elements.serversList = document.querySelector('.servers-list');
        this.elements.roomsList = document.querySelector('.rooms-list');
        this.elements.membersList = document.querySelector('.members-list');
        this.elements.messagesContainer = document.querySelector('.messages-container');
        this.elements.serversPanel = document.getElementById('servers-panel'); 
        this.elements.roomsPanel = document.getElementById('rooms-panel'); 
        this.elements.sidebar = document.querySelector('.sidebar');
        this.elements.membersPanel = document.querySelector('.members-panel');
        this.elements.serverSearchInput = document.querySelector('#serverSearch');
        this.elements.clearSearchBtn = document.querySelector('#clearSearchBtn');
        this.elements.backBtn = document.querySelector('.back-btn');
        this.elements.pttSetupBtn = document.querySelector('.ptt-setup-btn');
        if (this.elements.clearSearchBtn) {
            this.elements.clearSearchBtn.addEventListener('click', () => {
                ServerManager.clearSearchAndShowAllServers(this);
            });
        } else {
            console.warn('Clear search button not found');
        }
    }

    initEventListeners() {
        console.log('Setting up event listeners...');
        if (this.elements.micButton) {
            this.elements.micButton.addEventListener('click', () => this.toggleMicrophone());
        }
        if (this.elements.micToggleBtn) {
            this.elements.micToggleBtn.addEventListener('click', () => this.toggleMicrophone());
        }
        if (this.elements.messageInput) {
            this.elements.messageInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    this.sendMessage(this.elements.messageInput.value);
                    this.elements.messageInput.value = '';
                }
            });
        }
        if (this.elements.sendButton) {
            this.elements.sendButton.addEventListener('click', () => {
                this.sendMessage(this.elements.messageInput.value);
                this.elements.messageInput.value = '';
            });
        }
        if (this.elements.toggleSidebarBtn) {
            this.elements.toggleSidebarBtn.addEventListener('click', () => {
                this.elements.sidebar.classList.toggle('open');
                if (this.elements.sidebar.classList.contains('open')) {
                    this.elements.membersPanel.classList.remove('open');
                }
            });
        }
        if (this.elements.toggleMembersBtn) {
            this.elements.toggleMembersBtn.addEventListener('click', () => {
                this.elements.membersPanel.classList.toggle('open');
                if (this.elements.membersPanel.classList.contains('open')) {
                    this.elements.sidebar.classList.remove('open');
                }
            });
        }
        if (this.elements.closePanelBtn) {
            this.elements.closePanelBtn.addEventListener('click', () => {
                this.elements.membersPanel.classList.remove('open');
            });
        }
        if (this.elements.closeSidebarBtn) {
            this.elements.closeSidebarBtn.addEventListener('click', () => {
                this.elements.sidebar.classList.remove('open');
            });
        }
        if (this.elements.settingsBtn) {
            this.elements.settingsBtn.addEventListener('click', () => {
                UIManager.openSettings(this);
            });
        }
        if (this.elements.createServerBtn) {
            this.elements.createServerBtn.addEventListener('click', () => {
                ServerManager.createServer(this);
            });
        }
        if (this.elements.createRoomBtn) {
            this.elements.createRoomBtn.addEventListener('click', () => {
                if (!this.currentServerId) {
                    alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä');
                    return;
                }
                UIManager.openCreateRoomModal(this, (name) => {
                    RoomManager.createRoom(this, this.currentServerId, name);
                });
            });
        }
        if (this.elements.serversToggleBtn) {
            this.elements.serversToggleBtn.addEventListener('click', () => {
                ServerManager.clearSearchAndShowAllServers(this);
                this.showPanel('servers');
            });
        }
        if (this.elements.roomsToggleBtn) {
            this.elements.roomsToggleBtn.addEventListener('click', () => {
                this.showPanel('rooms');
            });
        }
        if (this.elements.serverSearchInput) {
            this.elements.serverSearchInput.addEventListener('input', (e) => {
                this.searchServers(e.target.value);
            });
        }
        if (this.elements.backBtn) {
            this.elements.backBtn.addEventListener('click', () => {
                this.goBackToMain();
            });
        }
        if (this.elements.pttSetupBtn) {
            this.elements.pttSetupBtn.addEventListener('click', () => {
                this.showPTTSetupModal();
            });
        }
        const mainContent = document.querySelector('.main-content');
        if (mainContent) {
            mainContent.addEventListener('click', (e) => {
                if (!e.target.closest('.message') &&
                    !e.target.closest('.message-input') &&
                    !e.target.closest('.send-btn') &&
                    !e.target.closest('.mic-toggle-btn') &&
                    !e.target.closest('.settings-btn') &&
                    !e.target.closest('.toggle-members-btn') &&
                    !e.target.closest('.current-room-title') &&
                    !e.target.closest('.toggle-sidebar-btn')) {
                    this.elements.sidebar.classList.remove('open');
                    this.elements.membersPanel.classList.remove('open');
                }
            });
        }
        const unlockBtn = document.getElementById('audio-unlock-btn');
        if (unlockBtn) {
            unlockBtn.addEventListener('click', () => {
                const audio = new Audio();
                audio.muted = true;
                audio.playsInline = true;
                audio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAA=';
                audio.play()
                    .then(() => {
                        console.log('‚úÖ –ê—É–¥–∏–æ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ!');
                        unlockBtn.style.display = 'none';
                    })
                    .catch(err => {
                        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ:', err);
                    });
            });
        }
        if (mainContent) {
            mainContent.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                mainContent.classList.add('drag-over');
            });
            mainContent.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                mainContent.classList.remove('drag-over');
            });
            mainContent.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                mainContent.classList.remove('drag-over');
                if (!this.currentRoom) {
                    this.showError('–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ –≤ –∫–æ–º–Ω–∞—Ç—É');
                    return;
                }
                const files = e.dataTransfer.files;
                if (files.length === 0) return;
                const file = files[0];
                if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
                    this.showError('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: JPEG, PNG, WebP');
                    return;
                }
                if (file.size > 5 * 1024 * 1024) {
                    this.showError('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 5 –ú–ë)');
                    return;
                }
                try {
                    const imageUrl = await TextChatManager.uploadImage(this, this.currentRoom, file);
                    await TextChatManager.sendMessage(this, imageUrl, 'image');
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
                    this.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ' + error.message);
                }
            });
        }
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/jpeg,image/png,image/webp';
        fileInput.style.display = 'none';
        fileInput.id = 'image-upload-input';
        document.body.appendChild(fileInput);
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (!this.currentRoom) {
                this.showError('–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ –≤ –∫–æ–º–Ω–∞—Ç—É');
                return;
            }
            if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
                this.showError('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: JPEG, PNG, WebP');
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                this.showError('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 5 –ú–ë)');
                return;
            }
            try {
                const imageUrl = await TextChatManager.uploadImage(this, this.currentRoom, file);
                await TextChatManager.sendImageMessage(this, imageUrl);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
                this.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ' + error.message);
            }
            fileInput.value = '';
        });
        const attachBtn = document.querySelector('.attach-btn');
        if (attachBtn) {
            attachBtn.addEventListener('click', () => {
                fileInput.click();
            });
        }
    }

    initMessageReadObserver() {
        this.unreadMessageIds = new Set();
        this.messageObserver = new IntersectionObserver((entries) => {
            const toMark = [];
            entries.forEach(entry => {
                const msgId = entry.target.dataset.messageId;
                if (!msgId) return;
                const readBy = JSON.parse(entry.target.dataset.readBy || '[]');
                const isOwn = entry.target.querySelector('.message-content.own');
                if (isOwn) return;
                if (entry.isIntersecting && !readBy.includes(this.userId)) {
                    toMark.push(msgId);
                    this.unreadMessageIds.delete(msgId);
                } else if (!entry.isIntersecting) {
                    this.unreadMessageIds.add(msgId);
                }
            });
            if (toMark.length > 0) {
                TextChatManager.markMessagesAsRead(this, toMark);
            }
        }, { threshold: 0.5 });
        window.voiceClient = this;
    }

    async sendImageMessage(imageUrl) {
        await TextChatManager.sendImageMessage(this, imageUrl);
    }

    showPanel(panelName) {
        console.log('Showing panel:', panelName);
        const serversPanel = this.elements.serversPanel;
        const roomsPanel = this.elements.roomsPanel;
        const serversToggleBtn = this.elements.serversToggleBtn;
        const roomsToggleBtn = this.elements.roomsToggleBtn;
        if (!serversPanel || !roomsPanel || !serversToggleBtn || !roomsToggleBtn) {
            console.error('Required panel elements not found');
            return;
        }
        this.activePanel = panelName;
        if (panelName === 'servers') {
            serversToggleBtn.classList.add('active');
            roomsToggleBtn.classList.remove('active');
            serversPanel.classList.add('active');
            roomsPanel.classList.remove('active');
        } else {
            serversToggleBtn.classList.remove('active');
            roomsToggleBtn.classList.add('active');
            serversPanel.classList.remove('active');
            roomsPanel.classList.add('active');
        }
    }

    processUrlParams() {
        console.log('Processing URL parameters...');
        const params = new URLSearchParams(window.location.search);
        this.currentServerId = params.get('server');
        this.currentRoom = params.get('room');
        this.inviteServerId = params.get('invite');
        const inviteCode = params.get('invite');
        if (inviteCode && /^[a-zA-Z0-9]{4}$/.test(inviteCode)) {
            this.pendingInviteCode = inviteCode;
            console.log('Found pending invite code:', inviteCode);
        }
        console.log('URL params processed - server:', this.currentServerId, 'room:', this.currentRoom, 'invite:', this.inviteServerId);
    }

    async ensureConsumer(producerId, producerData = {}) {
        console.group('üîÑ VoiceChatClient.ensureConsumer - START');
        console.log('üîπ producerId:', producerId);
        console.log('üîπ producerData:', producerData);
        const currentState = this.consumerState.get(producerId);
        if (currentState?.status === 'active') {
            console.log('‚ÑπÔ∏è Consumer already active for:', producerId);
            console.groupEnd();
            return true;
        }
        if (currentState?.status === 'creating') {
            console.log('‚ÑπÔ∏è Consumer already being created for:', producerId);
            console.groupEnd();
            return false;
        }
        this.consumerState.set(producerId, { status: 'creating', consumer: null, lastError: null });
        try {
            console.log('üîÑ Starting creation for producer:', producerId);
            const consumer = await MediaManager.createConsumer(this, producerId, 3, producerData);
            this.consumerState.set(producerId, { status: 'active', consumer: consumer, lastError: null });
            console.log('‚úÖ Consumer created and activated for:', producerId);
            console.groupEnd();
            return true;
        } catch (error) {
            console.error('‚ùå Failed to create consumer for:', producerId, error);
            this.consumerState.set(producerId, { 
                status: 'error', 
                consumer: null, 
                lastError: error 
            });
            if (error.message.includes('consume own') || error.message.includes('own audio')) {
                this.consumerState.set(producerId, { status: 'active', consumer: null, lastError: null });
                console.log('üîá Own producer marked as handled:', producerId);
            }
            console.groupEnd();
            return false;
        }
    }

    async initAutoConnect() {
        console.log('Starting auto-connect process...');
        this.processUrlParams();
        try {
            const autoLoggedIn = await AuthManager.tryAutoLogin(this);
            if (autoLoggedIn) {
                console.log('Auto-login successful, loading servers...');
                await ServerManager.loadServers(this);
                if (this.pendingInviteCode) {
                    console.log('Applying pending invite:', this.pendingInviteCode);
                    const inviteApplied = await InviteManager.applyPendingInvite();
                    if (inviteApplied) {
                        console.log('Invite applied successfully');
                        this.clearPendingInvite();
                        if (this.currentRoom && this.currentServerId) {
                            console.log('Invite was for a room. Attempting to join room:', this.currentRoom);
                            try {
                                await this.joinRoom(this.currentRoom);
                                console.log('Successfully joined room after invite application');
                            } catch (error) {
                                console.error('Failed to join room after invite application:', error);
                                UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–Ω–≤–∞–π—Ç–∞');
                            }
                        }
                        return;
                    } else {
                        console.log('Failed to apply invite, continuing with normal flow');
                    }
                }
                const lastServerId = localStorage.getItem('lastServerId');
                const lastRoomId = localStorage.getItem('lastRoomId');
                if (lastServerId) {
                    console.log('Found last server in localStorage:', lastServerId);
                    const serverExists = this.servers.some(s => s.id === lastServerId);
                    if (serverExists) {
                        this.currentServerId = lastServerId;
                        this.currentServer = this.servers.find(s => s.id === lastServerId);
                        await RoomManager.loadRoomsForServer(this, lastServerId);
                        if (lastRoomId) {
                            console.log('Found last room in localStorage:', lastRoomId);
                            const roomExists = this.rooms.some(room => room.id === lastRoomId);
                            if (roomExists) {
                                this.currentRoom = lastRoomId;
                                await this.reconnectToRoom(lastRoomId);
                                return;
                            }
                        }
                    }
                }
                let targetServerId = null;
                if (this.inviteServerId) {
                    console.log('Processing invite server ID:', this.inviteServerId);
                    const serverExists = this.servers.some(s => s.id === this.inviteServerId);
                    if (serverExists) {
                        targetServerId = this.inviteServerId;
                    } else {
                        const joined = await this.joinServer(this.inviteServerId);
                        if (joined) {
                            targetServerId = this.inviteServerId;
                            await ServerManager.loadServers(this);
                        } else {
                            UIManager.showError('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–µ—Ä–≤–µ—Ä—É.');
                        }
                    }
                } else if (this.currentServerId) {
                    console.log('Processing current server ID:', this.currentServerId);
                    const serverExists = this.servers.some(s => s.id === this.currentServerId);
                    if (serverExists) {
                        targetServerId = this.currentServerId;
                    }
                }
                if (targetServerId) {
                    console.log('Setting target server:', targetServerId);
                    this.currentServerId = targetServerId;
                    await RoomManager.loadRoomsForServer(this, targetServerId);
                    if (this.currentRoom) {
                        await this.reconnectToRoom(this.currentRoom);
                    }
                } else {
                    console.log('No target server found, showing auto-connect UI');
                    this.autoConnect();
                }
                return;
            }
            console.log('No auto-login found, showing auth modal');
            AuthManager.showAuthModal(this);
        } catch (err) {
            console.error('Auto connect error:', err);
            UIManager.showError('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏');
        }
    }

    clearPendingInvite() {
        console.log('Clearing pending invite');
        this.pendingInviteCode = null;
        localStorage.removeItem('pending_invite');
        const url = new URL(window.location);
        url.searchParams.delete('invite');
        window.history.replaceState({}, '', url);
    }

    async joinServer(serverId) {
        console.log('Joining server:', serverId);
        try {
            const res = await fetch(`${this.API_SERVER_URL}/api/servers/${serverId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.token}`
                },
                body: JSON.stringify({ userId: this.userId, token: this.token })
            });
            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è');
            }
            const data = await res.json();
            const server = data.server;
            const exists = this.servers.some(s => s.id === server.id);
            if (!exists) {
                this.servers.push(server);
                ServerManager.saveServersToLocalStorage(this);
            }
            if (this.elements.serverSearchInput) {
                this.elements.serverSearchInput.value = '';
            }
            localStorage.setItem('lastServerId', server.id);
            ServerManager.renderServers(this);
            this.showPanel('servers');
            UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ "${server.name}"`);
            return true;
        } catch (error) {
            console.error('Error joining server:', error);
            UIManager.showError(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è: ${error.message}`);
            return false;
        }
    }

    async joinRoom(roomId) {
        console.log('Joining room:', roomId);
        if (this.currentRoom === roomId && this.isConnected && this.socket && this.socket.connected) {
            console.log('Already connected to this room, updating consumers');
            await this.startConsuming();
            return true;
        }
        try {
            UIManager.addMessage('System', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ...');
            this.disconnectFromRoom();
            const res = await fetch(this.CHAT_API_URL, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json', 
                    'Authorization': `Bearer ${this.token}` 
                },
                body: JSON.stringify({ 
                    roomId, 
                    userId: this.userId, 
                    token: this.token, 
                    clientId: this.clientID 
                })
            });
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || `–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: ${res.status}`);
            }
            const data = await res.json();
            if (!data.success) throw new Error(data.error);
            if (!data.mediaData) {
                throw new Error('No media data received from server');
            }
            this.clientID = data.clientId;
            this.mediaData = data.mediaData;
            this.currentRoom = roomId;
            this.roomType = 'voice';
            localStorage.setItem('lastServerId', this.currentServerId);
            localStorage.setItem('lastRoomId', this.currentRoom);
            this.audioProducer = null;
            await MediaManager.connect(this, roomId, data.mediaData);
            this.setupSocketConnection();
            this.updateMicButtonState();
            if (this.socket) {
                this.socket.emit('subscribe-to-producers', { roomId });
                this.socket.emit('get-current-producers', { roomId });
            }
            UIManager.updateRoomUI(this);
            TextChatManager.joinTextRoom(this, roomId);
            await TextChatManager.loadMessages(this, roomId);
            UIManager.addMessage('System', `‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ`);
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                const btn = document.getElementById('ios-audio-unlock');
                if (btn) btn.style.display = 'block';
            }
            return true;
        } catch (e) {
            console.error('Error joining room:', e);
            UIManager.updateStatus('–û—à–∏–±–∫–∞: ' + e.message, 'disconnected');
            UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ' + e.message);
            throw e;
        }
    }

    setupSocketConnection() {
        console.log('Setting up socket connection...');
        if (this.socket && this.socket.connected) {
            console.log('Socket already connected, reusing');
            return;
        }
        const currentToken = this.token;
        if (!currentToken) {
            console.log('No token available, skipping socket connection');
            return;
        }
        this.destroySocket();
        try {
            console.log('Creating new socket connection with token:', currentToken);
            this.socket = io(this.API_SERVER_URL, {
                auth: {
                    token: currentToken,
                    userId: this.userId,
                    clientId: this.clientID,
                    username: this.username
                },
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                timeout: 20000
            });
            const socket = this.socket;
            socket.on('new-producer', async (data) => {
                console.group('üî¥üî¥üî¥ [DEBUG] SOCKET EVENT: new-producer');
                console.log('üéØ [DEBUG] EVENT DATA RECEIVED:', JSON.stringify(data, null, 2));
                console.log('üéØ [DEBUG] CLIENT STATE - clientID:', this.clientID);
                console.log('üéØ [DEBUG] Window producerClientMap before:', window.producerClientMap ? Array.from(window.producerClientMap.entries()) : 'undefined');
                console.groupEnd();
                console.log('üéØ New producer event:', data);
                if (data.producerId && data.clientID) {
                    if (!window.producerClientMap) window.producerClientMap = new Map();
                    window.producerClientMap.set(data.producerId, data.clientID);
                    console.log('üíæ Saved producerId ‚Üí clientID:', data.producerId, '‚Üí', data.clientID);
                }
                if (data.clientID !== this.clientID) {
                    console.log('üîπ Creating consumer for external producer');
                    await this.ensureConsumer(data.producerId, data);
                } else {
                    console.log('üîá Ignoring own producer:', data.producerId);
                    this.consumerState.set(data.producerId, { status: 'active', consumer: null, lastError: null });
                }
                console.group('üî¥üî¥üî¥ [DEBUG] AFTER PROCESSING new-producer');
                console.log('üéØ [DEBUG] Window producerClientMap after:', window.producerClientMap ? Array.from(window.producerClientMap.entries()) : 'undefined');
                console.groupEnd();
            });
            socket.on('current-producers', async (data) => {
                console.log('üéØ Current producers event:', data);
                if (!data || !data.producers || !Array.isArray(data.producers)) {
                    console.log('No producers data available');
                    return;
                }
                for (const producer of data.producers) {
                    if (producer.clientID !== this.clientID) {
                        await this.ensureConsumer(producer.id, producer);
                    } else {
                        this.consumerState.set(producer.id, { status: 'active', consumer: null, lastError: null });
                    }
                }
            });
            socket.on('room-participants', (participants) => {
                console.log('üéØ [CLIENT] Received room-participants event. Replacing entire members list.');
                const processedParticipants = participants.map(p => {
                    if (p.userId === this.userId) {
                        return { ...p, isOnline: true };
                    }  
                    return p;
                });
                MembersManager.updateAllMembers(processedParticipants);
                console.log('‚úÖ [CLIENT] Members list fully replaced.');
                if (!window.voiceClient) {
                    window.voiceClient = {};
                }
                const me = processedParticipants.find(p => p.userId);
                if (me) {
                    window.voiceClient.userId = me.userId;
                    const displayName = me.username || me.name || me.userId;
                    if (typeof window.setLoggerDisplayName === 'function') {
                        window.setLoggerDisplayName(displayName);
                    }
                }
            });
            socket.on('user-joined', (user) => {
                console.log('User joined:', user);
                UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user.username} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ`);
                this.playSound('user-join');
            });
            socket.on('user-left', async (data) => {
                console.group('üî¥üî¥üî¥ [DEBUG] SOCKET EVENT: user-left');
                console.log('üéØ [DEBUG] EVENT DATA RECEIVED:', JSON.stringify(data, null, 2));
                console.groupEnd();
                console.log('User left:', data.userId);
                const member = MembersManager.getMember(data.userId);
                const memberElement = document.querySelector(`.member-item[data-user-id="${data.userId}"]`);
                if (memberElement) {
                    const slider = memberElement.querySelector('.member-volume-slider');
                    if (slider) {
                        slider.style.display = 'none';
                        slider.dataset.producerId = '';
                        console.log('üîá Volume slider hidden for user:', data.userId);
                    }
                    const statusIndicator = memberElement.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.className = 'status-indicator offline';
                        statusIndicator.title = 'Offline';
                    }
                    const micIndicator = memberElement.querySelector('.mic-indicator');
                    if (micIndicator) {
                        micIndicator.className = 'mic-indicator';
                        micIndicator.title = 'Microphone muted';
                    }
                }
                if (member) {
                    member.isOnline = false;
                    UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${member.username} –ø–æ–∫–∏–Ω—É–ª –∫–æ–º–Ω–∞—Ç—É`);
                } else {
                    UIManager.addMessage('System', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–∫–∏–Ω—É–ª –∫–æ–º–Ω–∞—Ç—É`);
                }
                this.playSound('user-leave');
            });
            socket.on('user-mic-state', (data) => {
                console.log('User mic state changed:', data);
                if (data.userId) {
                    MembersManager.updateMember(data.userId, { isMicActive: data.isActive });
                } else {
                    const members = MembersManager.getMembers();
                    const member = members.find(m => m.clientId === data.clientID);
                    if (member) {
                        MembersManager.updateMember(member.userId, { isMicActive: data.isActive });
                    }
                }
            });
            socket.on('new-message', (message) => {
                console.log('New message received:', message);
                if (message.roomId === this.currentRoom) {
                    UIManager.addMessage(
                        message.username,
                        message.text,
                        message.timestamp,
                        message.type || 'text',
                        message.imageUrl,
                        message.id,
                        message.readBy || [],
                        message.userId // ‚Üê –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–¥–∞—ë–º userId
                    );
                    if (message.type !== 'image' && message.userId !== this.userId) {
                        this.playSound('message');
                    }
                }
            });
            socket.on('message-history', (data) => {
                console.log('Message history received:', data);
                if (data.roomId === this.currentRoom && data.messages) {
                    UIManager.clearMessages();
                    data.messages.forEach(msg => {
                        UIManager.addMessage(
                            msg.username,
                            msg.text,
                            msg.timestamp,
                            'text',
                            null,
                            msg.id,
                            msg.readBy || [],
                            msg.userId // ‚Üê –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–¥–∞—ë–º userId
                        );
                    });
                }
            });
            socket.on('error', (error) => {
                console.error('Socket error:', error);
                UIManager.showError('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ' + (error.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            });
            socket.on('connect', () => {
                console.log('‚úÖ Socket connected with ID:', socket.id);
                UIManager.updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ', 'connected');
                if (this.currentRoom) {
                    console.log('Rejoining room after socket reconnect:', this.currentRoom);
                    socket.emit('join-room', { roomId: this.currentRoom });
                    socket.emit('subscribe-to-producers', { roomId: this.currentRoom });
                    socket.emit('get-current-producers', { roomId: this.currentRoom });
                }
            });
            socket.on('disconnect', (reason) => {
                console.log('Socket disconnected:', reason);
                UIManager.updateStatus('–û—Ç–∫–ª—é—á–µ–Ω–æ', 'disconnected');
            });
        } catch (error) {
            console.error('Error setting up socket connection:', error);
            UIManager.showError('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É');
        }
    }

    destroySocket() {
        console.log('Destroying socket connection...');
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }

    updateMicButtonState() {
        let status;
        if (!this.isConnected) {
            status = 'disconnected';
        } else if (this.isMicActive) {
            status = 'active';
        } else {
            status = 'connected';
        }
        UIManager.updateMicButton(status);
    }

    async toggleMicrophone(forceState = null) {
        console.log('Toggling microphone, current state:', this.isMicActive, 'PTT active:', this.isPTTActive);
        
        // üö´ –ï—Å–ª–∏ –ø—ã—Ç–∞–µ–º—Å—è –≤—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω, –Ω–æ PTT –∞–∫—Ç–∏–≤–µ–Ω - –±–ª–æ–∫–∏—Ä—É–µ–º
        if (forceState === false && this.isPTTActive) {
            console.log('[PTT] Blocking mic disable - PTT is active');
            return;
        }

        try {
            if (!this.currentRoom) {
                UIManager.showError('–ú–∏–∫—Ä–æ—Ñ–æ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤ –∫–æ–º–Ω–∞—Ç–∞—Ö');
                return;
            }

            const targetState = forceState !== null ? forceState : !this.isMicActive;

            if (targetState) {
                // –í–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
                console.log('[PTT] Enabling microphone...');
                const enabled = await MediaManager.enableMicrophone(this);
                if (!enabled) {
                    if (!this.sendTransport && this.mediaData) {
                        await MediaManager.connect(this, this.currentRoom, this.mediaData);
                    }
                    await MediaManager.startMicrophone(this);
                }
                this.playSound('mic-on');
            } else {
                // –í—ã–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
                console.log('[PTT] Disabling microphone...');
                const disabled = await MediaManager.disableMicrophone(this);
                if (!disabled) {
                    await MediaManager.stopMicrophone(this, false);
                }
                this.playSound('mic-off');
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º UI –∏ —Ä–∞—Å—Å—ã–ª–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            UIManager.updateMemberMicState(this.userId, this.isMicActive);
            if (this.socket) {
                this.socket.emit('mic-state-change', {
                    roomId: this.currentRoom,
                    isActive: this.isMicActive,
                    clientID: this.clientID,
                    userId: this.userId
                });
            }

            this.updateMicButtonState();

        } catch (error) {
            console.error('Error toggling microphone:', error);
            UIManager.showError('–û—à–∏–±–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: ' + error.message);
            this.updateMicButtonState();
            throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤—ã—à–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤ PTT
        }
    }

    sendMessage(text) {
        console.log('Sending message:', text);
        if (!text.trim()) return;
        if (!this.currentRoom) {
            this.showError('–í—ã –Ω–µ –≤ –∫–æ–º–Ω–∞—Ç–µ');
            return;
        }
        if (this.socket) {
            this.socket.emit('send-message', {
                roomId: this.currentRoom,
                text: text.trim()
            });
        } else {
            TextChatManager.sendMessage(this, text).catch((error) => {
                console.error('Error sending message:', error);
                this.showError('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è');
            });
        }
    }

    async startConsuming() {
        console.log('üîÑ Starting media consumption...');
        if (!this.isConnected || !this.currentRoom) {
            console.log('Not connected or no room, skipping consumption');
            return;
        }
        try {
            const timestamp = Date.now();
            const response = await fetch(`${this.API_SERVER_URL}/api/media/rooms/${this.currentRoom}/producers?t=${timestamp}`, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache'
                }
            });
            if (!response.ok) {
                console.error(`‚ùå HTTP error! status: ${response.status}`);
                return;
            }
            const data = await response.json();
            const producers = data.producers || [];
            console.log(`üìã Found ${producers.length} producers in room ${this.currentRoom}`);
            for (const producer of producers) {
                if (producer.clientID !== this.clientID) {
                    await this.ensureConsumer(producer.id, producer);
                } else {
                    this.consumerState.set(producer.id, { status: 'active', consumer: null, lastError: null });
                }
            }
        } catch (error) {
            console.error('‚ùå Error starting consuming:', error);
        }
    }

    async disconnectFromRoom() {
        console.log('Disconnecting from room:', this.currentRoom);
        if (this.currentRoom) {
            if (this.socket) {
                this.socket.emit('leave-room', { roomId: this.currentRoom });
            }
            MediaManager.disconnect(this);
            TextChatManager.leaveTextRoom(this, this.currentRoom);
            MembersManager.clearMembers();
            this.destroySocket();
            this.currentRoom = null;
            this.isConnected = false;
            this.isMicActive = false;
            this.consumerState.clear();
            this.updateMicButtonState();
        }
    }

    async reconnectToRoom(roomId) {
        console.log('Reconnecting to room:', roomId);
        try {
            UIManager.addMessage('System', '–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ...');
            this.wasMicActiveBeforeReconnect = this.isMicActive;
            if (this.isMicActive && this.mediaData) {
                await MediaManager.stopMicrophone(this);
            }
            await this.leaveRoom();
            this.isReconnecting = true;
            await new Promise(resolve => setTimeout(resolve, 500));
            const result = await this.joinRoom(roomId);
            this.isReconnecting = false;
            if (this.wasMicActiveBeforeReconnect && this.mediaData) {
                setTimeout(async () => {
                    try {
                        await MediaManager.startMicrophone(this);
                        this.wasMicActiveBeforeReconnect = false;
                        setTimeout(() => {
                            this.forceRefreshProducers();
                        }, 2000);
                    } catch (error) {
                        console.error('Failed to restart microphone after reconnect:', error);
                        UIManager.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω –ø–æ—Å–ª–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                    }
                }, 3000);
            }
            return result;
        } catch (error) {
            this.isReconnecting = false;
            UIManager.addMessage('System', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
            throw error;
        }
    }

    async leaveRoom() {
        console.log('Leaving room:', this.currentRoom);
        if (!this.currentRoom) return;
        try {
            if (this.socket) {
                this.socket.emit('leave-room', { roomId: this.currentRoom });
            }
            if (this.isConnected) {
                MediaManager.disconnect(this);
            }
            await fetch(`${this.API_SERVER_URL}/api/media/rooms/${this.currentRoom}/leave`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            document.querySelectorAll('.member-volume-slider').forEach(slider => {
                slider.style.display = 'none';
                slider.dataset.producerId = '';
                console.log('üîá Volume slider cleared on room leave:', slider);
            });
            MembersManager.clearMembers();
            this.currentRoom = null;
            this.roomType = null;
            UIManager.updateRoomUI(this);
            UIManager.addMessage('System', `‚úÖ –í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –∫–æ–º–Ω–∞—Ç—É`);
            return true;
        } catch (error) {
            console.error('Error leaving room:', error);
            UIManager.showError('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∏–¥–∞–Ω–∏–∏ –∫–æ–º–Ω–∞—Ç—ã: ' + error.message);
            return false;
        }
    }

    autoConnect() {
        console.log('Showing auto-connect UI');
        this.elements.sidebar.classList.add('open');
    }

    showMessage(user, text) {
        UIManager.addMessage(user, text);
    }

    showError(text) {
        UIManager.showError(text);
    }

    async searchServers(query) {
        console.log('Searching servers:', query);
        await ServerManager.searchServers(this, query);
    }

    async checkRoomState() {
        if (!this.currentRoom) {
            console.log('No current room to check');
            return;
        }
        try {
            const response = await fetch(`${this.API_SERVER_URL}/api/debug/room/${this.currentRoom}`, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            if (response.ok) {
                const roomState = await response.json();
                console.log('üè† Room state:', roomState);
                const ourTransport = roomState.transports.find(t => t.clientID === this.clientID && t.direction === 'recv');
                console.log('üì° Our receive transport:', ourTransport);
                const ourConsumers = roomState.consumers.filter(c => c.clientID === this.clientID);
                console.log('üéß Our consumers:', ourConsumers);
                return roomState;
            } else {
                console.error('Failed to get room state:', response.status);
            }
        } catch (error) {
            console.error('Error checking room state:', error);
        }
    }

    async forceRefreshProducers() {
        try {
            console.log('üîÑ Force refreshing producers...');
            const timestamp = Date.now();
            const response = await fetch(`${this.API_SERVER_URL}/api/media/rooms/${this.currentRoom}/producers/force?t=${timestamp}`, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache'
                }
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            const producers = data.producers || [];
            console.log(`üìã Force refresh found ${producers.length} producers`);
            for (const producer of producers) {
                if (producer.clientID !== this.clientID && !this.existingProducers.has(producer.id)) {
                    try {
                        await MediaManager.createConsumer(this, producer.id);
                        this.existingProducers.add(producer.id);
                        console.log(`üéß Created consumer for producer: ${producer.id}`);
                    } catch (error) {
                        console.error('‚ùå Error creating consumer:', error);
                        if (error.message.includes('consume own')) {
                            this.existingProducers.add(producer.id);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå Error force refreshing producers:', error);
        }
    }

    // === PTT & BACK BUTTON LOGIC ===
    goBackToMain() {
        console.log('Going back to main addon manager...');
        if (window.electronAPI && typeof window.electronAPI.goBack === 'function') {
            window.electronAPI.goBack();
        } else {
            console.error('electronAPI.goBack is not available');
        }
    }

    async showPTTSetupModal() {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.style.display = 'flex';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Push-to-Talk</h2>
                <p>–ù–∞–∂–º–∏—Ç–µ –ª—é–±—É—é –∫–æ–º–±–∏–Ω–∞—Ü–∏—é –∫–ª–∞–≤–∏—à (–Ω–∞–ø—Ä–∏–º–µ—Ä, Ctrl+Shift+A)</p>
                <input type="text" id="pttHotkeyInput" placeholder="–ù–∞–∂–º–∏—Ç–µ –∫–ª–∞–≤–∏—à–∏..." readonly style="width: 100%; padding: 10px; margin: 10px 0; text-align: center; font-size: 16px;">
                <div class="modal-buttons">
                    <button id="confirmPTT">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button id="cancelPTT">–û—Ç–º–µ–Ω–∞</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);
        const hotkeyInput = modalOverlay.querySelector('#pttHotkeyInput');
        let capturedKeys = [];
        const keyHandler = (e) => {
            e.preventDefault();
            const key = this.getKeyString(e);
            if (key && !capturedKeys.includes(key)) {
                capturedKeys.push(key);
                hotkeyInput.value = capturedKeys.join('+');
            }
        };
        const keyUpHandler = (e) => {
            document.removeEventListener('keydown', keyHandler);
            document.removeEventListener('keyup', keyUpHandler);
        };
        document.addEventListener('keydown', keyHandler);
        document.addEventListener('keyup', keyUpHandler, { once: true });
        modalOverlay.querySelector('#confirmPTT').addEventListener('click', async () => {
            if (capturedKeys.length > 0) {
                const hotkeyString = capturedKeys.join('+');
                const result = await window.electronAPI.setPTTHotkey(hotkeyString);
                if (result.success) {
                    this.pttHotkey = hotkeyString;
                    UIManager.showError(`PTT —É—Å–ø–µ—à–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω: ${hotkeyString}`);
                } else {
                    UIManager.showError(`–û—à–∏–±–∫–∞: ${result.message}`);
                }
            }
            modalOverlay.remove();
        });
        modalOverlay.querySelector('#cancelPTT').addEventListener('click', () => {
            modalOverlay.remove();
        });
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.remove();
            }
        });
    }

    getKeyString(e) {
        let key = '';
        if (e.ctrlKey) key += 'Ctrl+';
        if (e.altKey) key += 'Alt+';
        if (e.shiftKey) key += 'Shift+';
        if (e.metaKey) key += 'Command+';
        const code = e.code.replace('Key', '').replace('Digit', '');
        if (code && !['ControlLeft', 'ControlRight', 'AltLeft', 'AltRight', 'ShiftLeft', 'ShiftRight', 'MetaLeft', 'MetaRight'].includes(e.code)) {
            key += code;
        }
        return key || null;
    }

    async handlePTTPressed() {
        if (!this.currentRoom) return;

        console.log('[PTT] PTT event received, current state:', {
            isMicActive: this.isMicActive,
            isPTTActive: this.isPTTActive,
            pttTimeoutId: this.pttTimeoutId
        });

        // üîÑ –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä –ø—Ä–∏ –õ–Æ–ë–û–ú —Å–æ–±—ã—Ç–∏–∏ PTT
        if (this.pttTimeoutId) {
            clearTimeout(this.pttTimeoutId);
            this.pttTimeoutId = null;
        }

        // üö´ –ï—Å–ª–∏ —É–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤–∫–ª—é—á–µ–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        if (this.isPTTActive && !this.isMicActive) {
            console.log('[PTT] Mic is still initializing, ignoring duplicate PTT');
            return;
        }

        // ‚úÖ –ï—Å–ª–∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω –ò PTT –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω - –≤–∫–ª—é—á–∞–µ–º –µ–≥–æ (–ø–µ—Ä–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ –ø—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏)
        if (!this.isMicActive && !this.isPTTActive) {
            console.log('[PTT] First press - enabling microphone');
            this.isPTTActive = true;
            
            try {
                await this.toggleMicrophone();
            } catch (error) {
                console.error('[PTT] Error enabling microphone:', error);
                this.isPTTActive = false;
                return;
            }
        }

        // ‚è∞ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∫–ª—é—á–∏—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω –µ—Å–ª–∏ —Å–æ–±—ã—Ç–∏—è –ø—Ä–µ–∫—Ä–∞—Ç—è—Ç—Å—è
        this.pttTimeoutId = setTimeout(async () => {
            console.log('[PTT] No PTT events for 300ms - releasing PTT');
            if (this.isMicActive) {
                await this.toggleMicrophone();
            }
            this.isPTTActive = false;
            this.pttTimeoutId = null;
        }, 300);
    }
}

window.debugForceRefresh = () => {
    if (window.debugVoiceClient) {
        window.debugVoiceClient.forceRefreshProducers();
    } else {
        console.error('Voice client not available for debugging');
    }
};

export default VoiceChatClient;

VolumeBoostManager.js:
// VolumeBoostManager.js
// –ú–æ–¥—É–ª—å –¥–ª—è —É—Å–∏–ª–µ–Ω–∏—è –∑–≤—É–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≥–æ–≤–æ—Ä—è—â–µ–≥–æ (gain/—É—Å–∏–ª–µ–Ω–∏–µ) –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º —á–∞—Ç–µ.
// –§–æ—Ä–º–∞—Ç: ES Module. –ü–æ–º–µ—â–∞–µ—Ç—Å—è –≤ renderer/voice/modules/
// –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å (–ø—Ä–∏–º–µ—Ä):
// import VolumeBoostManager from './modules/VolumeBoostManager.js';
// VolumeBoostManager.resume(); // —Ä–µ–∑—é–º–∏—Ä—É–µ—Ç AudioContext –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å –ø–æ user gesture)
// // –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å HTMLAudioElement, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º:
// VolumeBoostManager.attachToAudioElement(audioElement, userId); // audioElement –º–æ–∂–µ—Ç –∏–º–µ—Ç—å srcObject = MediaStream –∏–ª–∏ src = URL
// VolumeBoostManager.setGain(userId, 1.8); // —É—Å–∏–ª–∏—Ç—å –≤ 1.8 —Ä–∞–∑–∞
// VolumeBoostManager.detach(userId); // –≤–µ—Ä–Ω—É—Ç—å –≤—Å—ë –Ω–∞–∑–∞–¥ –∏ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å —Ä–µ—Å—É—Ä—Å—ã
//
// –ü—Ä–∏–º–µ—á–∞–Ω–∏—è:
// - –ú–æ–¥—É–ª—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç WebAudio API: AudioContext, GainNode, MediaStreamDestination –∏ MediaStreamSource.
// - –ï—Å–ª–∏ audioElement —É–∂–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–ª –ø–æ—Ç–æ–∫, –º–æ–¥—É–ª—å –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —á–µ—Ä–µ–∑ internal MediaStreamDestination.
// - –ù–µ –∏–∑–º–µ–Ω—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏/detach –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ-—ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –º–µ—Ä—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏).

class VolumeBoostManager {
    static audioCtx = null;
    // userId => { source, gainNode, dest, audioElement, originalSrcObject }
    static boosts = new Map();

    static _ensureAudioContext() {
        if (!this.audioCtx) {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return this.audioCtx;
    }

    // Resume context (call on user gesture if needed)
    static async resume() {
        const ctx = this._ensureAudioContext();
        if (ctx.state === 'suspended') {
            try {
                await ctx.resume();
                console.log('VolumeBoostManager: AudioContext resumed');
            } catch (e) {
                console.warn('VolumeBoostManager: resume failed', e);
            }
        }
    }

    // Attach boost to HTMLAudioElement. audioElement can have .srcObject (MediaStream) or .src (URL)
    static attachToAudioElement(audioElement, userId, initialGain = 1.0) {
        if (!audioElement) return;
        const ctx = this._ensureAudioContext();

        // If there is already a boost for this user, detach first
        if (this.boosts.has(userId)) {
            this.detach(userId);
        }

        let src = null;
        let createdFromStream = false;
        let originalSrcObject = audioElement.srcObject;

        try {
            if (audioElement.srcObject instanceof MediaStream) {
                // create MediaStreamSource from the stream
                src = ctx.createMediaStreamSource(audioElement.srcObject);
                createdFromStream = true;
            } else {
                // create source from media element
                // Note: createMediaElementSource requires the element to be in the same document and not cross-origin for audio graph.
                src = ctx.createMediaElementSource(audioElement);
            }
        } catch (e) {
            console.warn('VolumeBoostManager: create source fallback', e);
            // If failed to create source (cross-origin or other), fallback to no-op
            return;
        }

        const gainNode = ctx.createGain();
        gainNode.gain.value = Number(initialGain) || 1.0;
        // Optional: add a soft limiter (dynamics compressor) to avoid clipping when applying large gain
        const compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -3; // dB
        compressor.knee.value = 6;
        compressor.ratio.value = 6;
        compressor.attack.value = 0.01;
        compressor.release.value = 0.2;

        // Create destination stream and route the processed audio to it
        const dest = ctx.createMediaStreamDestination();
        // Source -> gain -> compressor -> dest
        src.connect(gainNode);
        gainNode.connect(compressor);
        compressor.connect(dest);

        // Preserve element's playback state; set new srcObject to processed stream
        try {
            // Pause, change source, then play if it was playing
            const wasPlaying = !audioElement.paused && !audioElement.ended;
            audioElement.pause();
            audioElement.srcObject = dest.stream;
            // keep same currentTime if applicable (note: for streams currentTime not used)
            if (wasPlaying) {
                // Some browsers require a user gesture to start audio; caller should handle resume()
                const p = audioElement.play();
                if (p && p.catch) p.catch(e => console.warn('VolumeBoostManager: play rejected', e));
            }
        } catch (e) {
            console.warn('VolumeBoostManager: error while reassigning srcObject', e);
        }

        this.boosts.set(userId, {
            source: src,
            gainNode,
            compressor,
            dest,
            audioElement,
            originalSrcObject,
            createdFromStream
        });

        console.log('VolumeBoostManager: attached boost for', userId, 'gain=', gainNode.gain.value);
    }

    // Attach boost directly to a MediaStream (no audio element handling) and return boosted MediaStream
    static attachToMediaStream(mediaStream, userId, initialGain = 1.0) {
        if (!(mediaStream instanceof MediaStream)) return null;
        const ctx = this._ensureAudioContext();
        if (this.boosts.has(userId)) this.detach(userId);

        const src = ctx.createMediaStreamSource(mediaStream);
        const gainNode = ctx.createGain();
        gainNode.gain.value = Number(initialGain) || 1.0;

        const compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -3;
        compressor.knee.value = 6;
        compressor.ratio.value = 6;
        compressor.attack.value = 0.01;
        compressor.release.value = 0.2;

        const dest = ctx.createMediaStreamDestination();
        src.connect(gainNode);
        gainNode.connect(compressor);
        compressor.connect(dest);

        this.boosts.set(userId, {
            source: src,
            gainNode,
            compressor,
            dest,
            audioElement: null,
            originalSrcObject: null,
            createdFromStream: true
        });

        console.log('VolumeBoostManager: attached to MediaStream for', userId, 'gain=', gainNode.gain.value);
        return dest.stream;
    }

    // Set gain for userId (1.0 = original, >1 = boost, <1 = attenuation)
    static setGain(userId, value) {
        const entry = this.boosts.get(userId);
        if (!entry) {
            console.warn('VolumeBoostManager: setGain no entry for', userId);
            return;
        }
        const v = Number(value);
        if (isNaN(v) || !isFinite(v)) return;
        // clamp to [0, 10] to avoid absurd values
        const clamped = Math.max(0, Math.min(10, v));
        entry.gainNode.gain.setValueAtTime(clamped, this.audioCtx.currentTime);
        console.log('VolumeBoostManager: setGain', userId, clamped);
    }

    // Detach and restore audioElement to original srcObject if possible
    static detach(userId) {
        const entry = this.boosts.get(userId);
        if (!entry) return;
        try {
            // disconnect nodes
            if (entry.source) {
                try { entry.source.disconnect(); } catch (e) {}
            }
            if (entry.gainNode) {
                try { entry.gainNode.disconnect(); } catch (e) {}
            }
            if (entry.compressor) {
                try { entry.compressor.disconnect(); } catch (e) {}
            }
            if (entry.dest) {
                try { entry.dest.disconnect(); } catch (e) {}
            }
            // restore audio element original stream if we modified it
            if (entry.audioElement) {
                try {
                    // Pause and restore original stream
                    const ae = entry.audioElement;
                    const wasPlaying = !ae.paused && !ae.ended;
                    ae.pause();
                    ae.srcObject = entry.originalSrcObject || null;
                    if (wasPlaying) {
                        const p = ae.play();
                        if (p && p.catch) p.catch(()=>{});
                    }
                } catch (e) {
                    console.warn('VolumeBoostManager: restore audioElement failed', e);
                }
            }
        } catch (e) {
            console.warn('VolumeBoostManager: detach error', e);
        } finally {
            this.boosts.delete(userId);
            console.log('VolumeBoostManager: detached', userId);
        }
    }

    // Detach all entries and close AudioContext (optional)
    static detachAll() {
        for (const userId of Array.from(this.boosts.keys())) {
            this.detach(userId);
        }
    }

    // Get current gain value for userId
    static getGain(userId) {
        const entry = this.boosts.get(userId);
        if (!entry) return null;
        return entry.gainNode.gain.value;
    }
}

export default VolumeBoostManager;


